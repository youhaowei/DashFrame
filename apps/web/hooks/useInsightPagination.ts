import { useCallback, useState, useEffect, useMemo } from "react";
import { useDuckDB } from "@/components/providers/DuckDBProvider";
import { useDataFrames, getDataFrame } from "@dashframe/core";
import {
  shortenAutoGeneratedName,
  ensureTableLoaded,
} from "@dashframe/engine-browser";
import type { FetchDataParams, FetchDataResult } from "@dashframe/ui";
import type { Insight, DataTable, UUID } from "@dashframe/types";

/**
 * Options for useInsightPagination hook.
 */
export interface UseInsightPaginationOptions {
  /** The insight configuration - contains joins, filters, metrics, selectedFields */
  insight: Insight;
  /** All data tables in the system (needed to resolve join table info) */
  allDataTables: DataTable[];
  /**
   * Show the data model preview (full joined data without transformations).
   * - false (default): Apply full insight query (aggregations, filters, sorts)
   * - true: Show all rows from joined tables, ignore aggregations/filters
   */
  showModelPreview?: boolean;
}

/**
 * Hook for paginated Insight queries via DuckDB.
 *
 * Supports two modes:
 * 1. Model preview (showModelPreview=true): Shows all rows from base + joined tables without aggregations/filters
 * 2. Insight query (showModelPreview=false): Applies full insight configuration (GROUP BY, metrics, filters, sorts)
 *
 * @example
 * ```tsx
 * const { fetchData, totalCount, fieldCount, isReady } = useInsightPagination({
 *   insight,
 *   allDataTables,
 *   showModelPreview: true // Show full joined data
 * });
 *
 * return isReady ? (
 *   <VirtualTable onFetchData={fetchData} />
 * ) : (
 *   <LoadingSpinner />
 * );
 * ```
 */
export function useInsightPagination({
  insight,
  allDataTables,
  showModelPreview = false,
}: UseInsightPaginationOptions) {
  const { connection, isInitialized } = useDuckDB();
  const { data: allDataFrames } = useDataFrames();

  // Find base table
  const baseTable = useMemo(
    () => allDataTables.find((t) => t.id === insight.baseTableId),
    [allDataTables, insight.baseTableId],
  );

  const [totalCount, setTotalCount] = useState<number>(0);
  const [columns, setColumns] = useState<{ name: string; type?: string }[]>([]);
  const [fieldCount, setFieldCount] = useState<number>(0);
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Build SQL for the insight query
  const buildSQL = useCallback(
    async (
      limit?: number,
      offset?: number,
      sortColumn?: string,
      sortDirection?: "asc" | "desc",
    ): Promise<string | null> => {
      if (!baseTable?.dataFrameId) return null;

      const baseDataFrameId = baseTable.dataFrameId;
      const baseDFTable = `df_${baseDataFrameId.replace(/-/g, "_")}`;
      const baseDisplayName = shortenAutoGeneratedName(baseTable.name);
      const baseFields = (baseTable.fields ?? []).filter(
        (f) => !f.name.startsWith("_"),
      );

      // No joins: simple query on base table with alias
      if (!insight.joins?.length) {
        let sql = `SELECT * FROM ${baseDFTable} AS "${baseDisplayName}"`;
        if (sortColumn && sortDirection) {
          sql += ` ORDER BY "${sortColumn}" ${sortDirection.toUpperCase()}`;
        }
        if (limit !== undefined) sql += ` LIMIT ${limit}`;
        if (offset !== undefined) sql += ` OFFSET ${offset}`;
        return sql;
      }

      // Has joins: build JOIN SQL with readable aliases
      const baseColNames = baseFields.map((f) => f.columnName ?? f.name);
      const baseColNamesLower = new Set(
        baseColNames.map((c) => c.toLowerCase()),
      );

      // Start with base table aliased as its display name
      let currentSQL = `${baseDFTable} AS "${baseDisplayName}"`;

      // Process each join
      for (const join of insight.joins) {
        const joinTable = allDataTables.find((t) => t.id === join.rightTableId);
        if (!joinTable) {
          console.warn(
            `Join table ${join.rightTableId} not found in allDataTables`,
          );
          continue;
        }
        if (!joinTable.dataFrameId) {
          console.warn(`Join table ${joinTable.name} has no dataFrameId`);
          continue;
        }

        const joinDFTable = `df_${joinTable.dataFrameId.replace(/-/g, "_")}`;
        const joinDisplayName = shortenAutoGeneratedName(joinTable.name);
        console.log(
          `Building JOIN SQL for table ${joinTable.name} -> ${joinDFTable} AS "${joinDisplayName}"`,
        );

        const joinFields = (joinTable.fields ?? []).filter(
          (f) => !f.name.startsWith("_"),
        );
        const joinColNames = joinFields.map((f) => f.columnName ?? f.name);

        // Find join key fields
        const baseKeyField = baseFields.find(
          (f) => (f.columnName ?? f.name) === join.leftKey,
        );
        const joinKeyField = joinFields.find(
          (f) => (f.columnName ?? f.name) === join.rightKey,
        );

        if (!baseKeyField || !joinKeyField) {
          console.warn(
            `Join key fields not found: ${join.leftKey}, ${join.rightKey}`,
          );
          continue;
        }

        const leftColName = baseKeyField.columnName ?? baseKeyField.name;
        const rightColName = joinKeyField.columnName ?? joinKeyField.name;

        // Build SELECT parts with collision handling
        const selectParts: string[] = [];

        // Add base columns (using baseDisplayName alias)
        for (const col of baseColNames) {
          const isDuplicate =
            joinColNames.some((jc) => jc.toLowerCase() === col.toLowerCase()) &&
            col.toLowerCase() !== leftColName.toLowerCase();

          if (isDuplicate) {
            const alias = `${baseDisplayName}.${col}`;
            selectParts.push(`"${baseDisplayName}"."${col}" AS "${alias}"`);
          } else {
            selectParts.push(`"${baseDisplayName}"."${col}"`);
          }
        }

        // Add joined columns (using joinDisplayName alias)
        for (const col of joinColNames) {
          const isDuplicate = baseColNamesLower.has(col.toLowerCase());
          const alias = isDuplicate ? `${joinDisplayName}.${col}` : col;
          if (isDuplicate) {
            selectParts.push(`"${joinDisplayName}"."${col}" AS "${alias}"`);
          } else {
            selectParts.push(`"${joinDisplayName}"."${col}"`);
          }
        }

        const joinTypeSQL = (join.type ?? "inner").toUpperCase();
        currentSQL = `(
          SELECT ${selectParts.join(", ")}
          FROM ${currentSQL}
          ${joinTypeSQL} JOIN ${joinDFTable} AS "${joinDisplayName}"
          ON "${baseDisplayName}"."${leftColName}" = "${joinDisplayName}"."${rightColName}"
        )`;
      }

      // In model preview mode: show all data without transformations
      if (showModelPreview) {
        let sql = `SELECT * FROM ${currentSQL}`;
        if (sortColumn && sortDirection) {
          sql += ` ORDER BY "${sortColumn}" ${sortDirection.toUpperCase()}`;
        }
        if (limit !== undefined) sql += ` LIMIT ${limit}`;
        if (offset !== undefined) sql += ` OFFSET ${offset}`;
        return sql;
      }

      // TODO: Implement full insight query mode with aggregations, filters, sorts
      // For now, fall back to model preview behavior
      let sql = `SELECT * FROM ${currentSQL}`;
      if (sortColumn && sortDirection) {
        sql += ` ORDER BY "${sortColumn}" ${sortDirection.toUpperCase()}`;
      }
      if (limit !== undefined) sql += ` LIMIT ${limit}`;
      if (offset !== undefined) sql += ` OFFSET ${offset}`;
      return sql;
    },
    [baseTable, allDataTables, insight.joins, showModelPreview],
  );

  // Load all required DataFrames into DuckDB and get metadata
  useEffect(() => {
    if (!connection || !isInitialized || !baseTable?.dataFrameId) {
      requestAnimationFrame(() => setIsReady(false));
      return;
    }

    const init = async () => {
      try {
        console.log("[useInsightPagination] Init starting", {
          baseTableId: baseTable.id,
          baseDataFrameId: baseTable.dataFrameId,
          joins: insight.joins,
          allDataTablesCount: allDataTables.length,
        });

        // Load base DataFrame into DuckDB
        const baseDataFrame = await getDataFrame(baseTable.dataFrameId!);
        if (!baseDataFrame) {
          setError(`Base DataFrame not found: ${baseTable.dataFrameId}`);
          setIsReady(false);
          return;
        }
        // Actually load table into DuckDB (not lazy)
        await ensureTableLoaded(baseDataFrame, connection);
        console.log(
          `[useInsightPagination] Loaded base table ${baseTable.name}`,
        );

        // Load joined DataFrames
        if (insight.joins?.length) {
          console.log(
            `[useInsightPagination] Loading ${insight.joins.length} joined tables`,
          );
          for (const join of insight.joins) {
            const joinTable = allDataTables.find(
              (t) => t.id === join.rightTableId,
            );
            if (!joinTable) {
              console.warn(
                `Join table ${join.rightTableId} not found in allDataTables`,
              );
              continue;
            }
            if (!joinTable.dataFrameId) {
              console.warn(`Join table ${joinTable.name} has no dataFrameId`);
              continue;
            }

            const joinDataFrame = await getDataFrame(joinTable.dataFrameId);
            if (!joinDataFrame) {
              console.warn(
                `DataFrame not found for join table ${joinTable.name}`,
              );
              continue;
            }

            // Load into DuckDB (idempotent - skips if already loaded)
            await ensureTableLoaded(joinDataFrame, connection);
            console.log(
              `Loaded join table ${joinTable.name} (${joinTable.dataFrameId}) into DuckDB`,
            );
          }
        }

        // Build SQL and get count
        const countSQL = await buildSQL();
        if (!countSQL) {
          setError("Failed to build SQL query");
          setIsReady(false);
          return;
        }

        console.log("[useInsightPagination] Generated SQL:", countSQL);
        const countQuery = `SELECT COUNT(*) as count FROM (${countSQL})`;
        console.log(
          "[useInsightPagination] Executing count query:",
          countQuery,
        );
        try {
          const countResult = await connection.query(countQuery);
          const count = Number(countResult.toArray()[0]?.count ?? 0);
          setTotalCount(count);
          console.log(
            "[useInsightPagination] Count query successful, rows:",
            count,
          );
        } catch (err) {
          console.error("[useInsightPagination] Count query failed:", err);
          throw err;
        }

        // Get column info from first row
        const previewSQL = await buildSQL(1);
        if (previewSQL) {
          console.log(
            "[useInsightPagination] Executing preview query for columns:",
            previewSQL,
          );
          try {
            const previewResult = await connection.query(previewSQL);
            const rows = previewResult.toArray() as Record<string, unknown>[];

            if (rows.length > 0) {
              const cols = Object.keys(rows[0])
                .filter((key) => !key.startsWith("_"))
                .map((name) => ({ name }));
              requestAnimationFrame(() => {
                setColumns(cols);
                setFieldCount(cols.length);
              });
              console.log(
                "[useInsightPagination] Preview query successful, columns:",
                cols.length,
              );
            }
          } catch (err) {
            console.error("[useInsightPagination] Preview query failed:", err);
            throw err;
          }
        }

        requestAnimationFrame(() => {
          setIsReady(true);
          setError(null);
        });
      } catch (err) {
        console.error("Failed to initialize insight pagination:", err);
        requestAnimationFrame(() => {
          setError(err instanceof Error ? err.message : "Failed to initialize");
          setIsReady(false);
        });
      }
    };

    init();
  }, [
    connection,
    isInitialized,
    baseTable?.dataFrameId,
    allDataTables,
    insight.joins,
    buildSQL,
  ]);

  // Fetch callback for VirtualTable
  const fetchData = useCallback(
    async (params: FetchDataParams): Promise<FetchDataResult> => {
      if (!connection || !isInitialized || !baseTable?.dataFrameId) {
        return { rows: [], totalCount: 0 };
      }

      try {
        // Ensure base DataFrame is loaded (idempotent)
        const baseDataFrame = await getDataFrame(baseTable.dataFrameId);
        if (!baseDataFrame) {
          return { rows: [], totalCount: 0 };
        }
        await ensureTableLoaded(baseDataFrame, connection);

        // Ensure all joined DataFrames are loaded (idempotent)
        if (insight.joins?.length) {
          for (const join of insight.joins) {
            const joinTable = allDataTables.find(
              (t) => t.id === join.rightTableId,
            );
            if (joinTable?.dataFrameId) {
              const joinDataFrame = await getDataFrame(joinTable.dataFrameId);
              if (joinDataFrame) {
                // Load into DuckDB (idempotent - skips if already loaded)
                await ensureTableLoaded(joinDataFrame, connection);
              }
            }
          }
        }

        // Build and execute SQL
        const sql = await buildSQL(
          params.limit,
          params.offset,
          params.sortColumn,
          params.sortDirection,
        );

        if (!sql) {
          console.warn("[fetchData] Failed to build SQL");
          return { rows: [], totalCount: 0 };
        }

        console.log("[fetchData] Executing query:", sql);
        try {
          const result = await connection.query(sql);
          const rows = result.toArray() as Record<string, unknown>[];
          console.log(
            "[fetchData] Query successful, returned",
            rows.length,
            "rows",
          );
          return { rows, totalCount };
        } catch (err) {
          console.error("[fetchData] Query failed:", err);
          console.error("[fetchData] Failed SQL:", sql);
          return { rows: [], totalCount: 0 };
        }
      } catch (err) {
        console.error("Failed to fetch insight data:", err);
        return { rows: [], totalCount: 0 };
      }
    },
    [
      connection,
      isInitialized,
      baseTable?.dataFrameId,
      allDataTables,
      insight.joins,
      buildSQL,
      totalCount,
    ],
  );

  return {
    fetchData,
    totalCount,
    columns,
    fieldCount,
    isReady,
    error,
  };
}
