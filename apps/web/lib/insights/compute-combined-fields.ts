import { shortenAutoGeneratedName } from "@dashframe/engine-browser";
import type {
  DataTable,
  Field,
  InsightJoinConfig,
  UUID,
} from "@dashframe/types";

/**
 * Field with additional metadata for combined (base + joined) views.
 */
export interface CombinedField extends Field {
  /** Original table this field came from */
  sourceTableId: UUID;
  /** Display name (may include table prefix for duplicates) */
  displayName: string;
}

/**
 * Computes combined field list from base table + joined tables.
 *
 * Handles column name collisions by prefixing duplicate names with
 * a shortened table name (e.g., "leads.id" vs "rooms.id").
 *
 * @param baseTable - The base data table
 * @param joins - Join configurations from the insight
 * @param allDataTables - All data tables (for resolving join table IDs)
 * @returns Combined field list and total count
 *
 * @example
 * ```ts
 * const { fields, count } = computeCombinedFields(
 *   leadsTable,
 *   [{ type: 'inner', rightTableId: roomsTableId, leftKey: 'room_id', rightKey: 'id' }],
 *   allTables
 * );
 * // fields contains all columns from both tables with duplicates prefixed
 * // count = 41 (36 from leads + 5 unique from rooms)
 * ```
 */
export function computeCombinedFields(
  baseTable: DataTable,
  joins: InsightJoinConfig[] | undefined,
  allDataTables: DataTable[],
): { fields: CombinedField[]; count: number } {
  // Start with base table fields (excluding internal _ prefixed fields)
  const baseFields = (baseTable.fields ?? []).filter(
    (f) => !f.name.startsWith("_"),
  );

  // If no joins, return base fields only
  if (!joins || joins.length === 0) {
    const combined: CombinedField[] = baseFields.map((f) => ({
      ...f,
      sourceTableId: baseTable.id,
      displayName: f.name,
    }));
    return { fields: combined, count: combined.length };
  }

  // Build combined field list
  const combined: CombinedField[] = [];
  const baseColNamesLower = new Set(
    baseFields.map((f) => (f.columnName ?? f.name).toLowerCase()),
  );

  // Shortened base table name for prefixing
  const baseDisplayName = shortenAutoGeneratedName(baseTable.name);

  // Add base table fields (with prefixes for duplicates)
  const joinColNamesLower = new Set<string>();

  // First pass: collect all column names from joined tables
  for (const join of joins) {
    const joinTable = allDataTables.find((t) => t.id === join.rightTableId);
    if (!joinTable) continue;

    const joinFields = (joinTable.fields ?? []).filter(
      (f) => !f.name.startsWith("_"),
    );
    joinFields.forEach((f) => {
      joinColNamesLower.add((f.columnName ?? f.name).toLowerCase());
    });
  }

  // Add base table fields with collision handling
  for (const field of baseFields) {
    const colName = field.columnName ?? field.name;
    const isDuplicate = joinColNamesLower.has(colName.toLowerCase());

    const displayName = isDuplicate
      ? `${baseDisplayName}.${field.name}`
      : field.name;

    combined.push({
      ...field,
      sourceTableId: baseTable.id,
      displayName,
    });
  }

  // Add joined table fields
  for (const join of joins) {
    const joinTable = allDataTables.find((t) => t.id === join.rightTableId);
    if (!joinTable) continue;

    const joinFields = (joinTable.fields ?? []).filter(
      (f) => !f.name.startsWith("_"),
    );
    const joinDisplayName = shortenAutoGeneratedName(joinTable.name);

    for (const field of joinFields) {
      const colName = field.columnName ?? field.name;
      const isDuplicate = baseColNamesLower.has(colName.toLowerCase());

      const displayName = isDuplicate
        ? `${joinDisplayName}.${field.name}`
        : field.name;

      combined.push({
        ...field,
        sourceTableId: joinTable.id,
        displayName,
      });
    }
  }

  return { fields: combined, count: combined.length };
}
