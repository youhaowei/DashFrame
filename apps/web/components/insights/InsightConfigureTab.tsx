/* eslint-disable @typescript-eslint/no-explicit-any -- Vega-Lite specs use dynamic types */
/* eslint-disable sonarjs/cognitive-complexity, sonarjs/no-nested-conditional */
"use client";

import { useMemo, useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import type { DataFrameColumn, DataFrameRow } from "@dashframe/types";
import {
  useDataFrames,
  useDataTables,
  useVisualizationMutations,
  useInsightMutations,
  useDataSources,
  getDataFrame,
} from "@dashframe/core";
import { useDataFrameData } from "@/hooks/useDataFrameData";
import { useDuckDB } from "@/components/providers/DuckDBProvider";
import {
  Button,
  Card,
  CardContent,
  CardHeader,
  Badge,
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
  ItemList,
  JoinTypeIcon,
  getJoinTypeLabel,
  VirtualTable,
  type ListItem,
  type FetchDataParams,
  type FetchDataResult,
} from "@dashframe/ui";
import { useDataFramePagination } from "@/hooks/useDataFramePagination";
import {
  Calculator,
  ChevronDown,
  Database,
  Hash,
  Plus,
  X,
} from "@dashframe/ui/icons";
import {
  computeInsightPreview,
  computeInsightDataFrame,
} from "@/lib/insights/compute-preview";
import type { PreviewResult } from "@/lib/insights/compute-preview";
import { suggestCharts } from "@/lib/visualizations/suggest-charts";
import type { ChartSuggestion } from "@/lib/visualizations/suggest-charts";
import { SuggestedInsights } from "@/components/visualization-preview/SuggestedInsights";
import { JoinFlowModal } from "@/components/visualizations/JoinFlowModal";
import type {
  UUID,
  Field as LocalField,
  Metric,
  ColumnType,
  Insight,
  DataTable,
  DataSource,
  InsightMetric,
  VegaLiteSpec,
} from "@dashframe/types";
import {
  shortenAutoGeneratedName,
  analyzeDataFrame,
  type ColumnAnalysis,
} from "@dashframe/engine-browser";

// Utility to format dates consistently
function formatDate(value: unknown): string | null {
  if (value instanceof Date && !isNaN(value.getTime())) {
    return value.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  }
  if (typeof value === "string") {
    const parsed = Date.parse(value);
    if (!isNaN(parsed)) {
      const date = new Date(parsed);
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
      });
    }
  }
  return null;
}

// Format cell value for display
function formatCellValue(value: unknown): string {
  if (value === null || value === undefined) return "";
  const dateStr = formatDate(value);
  if (dateStr) return dateStr;
  if (typeof value === "number") return value.toLocaleString();
  return String(value);
}

interface InsightConfigureTabProps {
  insightId: UUID;
  insight: Insight;
  dataTable: DataTable;
  fields: LocalField[];
  tableMetrics: Metric[];
  insightMetrics: InsightMetric[];
  dataSource: DataSource | null;
  isConfigured: boolean;
}

/**
 * Configure Tab Content
 *
 * Shows different content based on configuration state:
 * - Unconfigured: Data preview + chart suggestions (like current create-visualization)
 * - Configured: Field/metric/filter/join editor
 */
export function InsightConfigureTab({
  insightId,
  insight,
  dataTable,
  fields,
  tableMetrics: _tableMetrics, // Kept for future use
  insightMetrics,
  dataSource,
  isConfigured,
}: InsightConfigureTabProps) {
  const router = useRouter();

  // Dexie hooks
  const { data: allDataFrameEntries = [] } = useDataFrames();
  const { data: allDataTables = [] } = useDataTables();
  const { create: createVisualizationLocal } = useVisualizationMutations();
  const { update: updateInsightLocal } = useInsightMutations();

  // Load source DataFrame data asynchronously from IndexedDB
  // Use Infinity to load all rows - aggregations need complete data for accurate results
  const { data: sourceDataFrameData, isLoading: isLoadingSourceData } =
    useDataFrameData(dataTable?.dataFrameId, { limit: Infinity });

  // Pagination hook for VirtualTable - enables efficient browsing of large datasets
  const {
    fetchData: fetchPreviewData,
    totalCount: previewTotalCount,
    isReady: isPreviewReady,
  } = useDataFramePagination(dataTable?.dataFrameId);

  // DuckDB connection for join computation
  const { connection: duckDBConnection, isInitialized: isDuckDBReady } =
    useDuckDB();

  // Local state
  const [isJoinFlowOpen, setIsJoinFlowOpen] = useState(false);
  const [suggestionSeed, setSuggestionSeed] = useState(0);

  // State for DuckDB-computed joined data (stores SQL for async pagination, not rows)
  const [joinedPreviewData, setJoinedPreviewData] = useState<{
    sql: string; // The join SQL for pagination queries
    columns: Array<{ name: string; type?: string; _isJoined?: boolean }>;
    totalCount: number;
    sampleRows: DataFrameRow[]; // Sample rows for chart suggestions and aggregation preview
  } | null>(null);
  const [isLoadingJoinedData, setIsLoadingJoinedData] = useState(false);

  // Column analysis state (DuckDB computed)
  const [columnAnalysis, setColumnAnalysis] = useState<ColumnAnalysis[]>([]);

  // Data sources (for join metadata)
  const { data: dataSources = [] } = useDataSources();

  // All visible fields from the table (for unconfigured preview)
  const allTableFields = useMemo(() => {
    return fields.filter((f) => !f.name.startsWith("_"));
  }, [fields]);

  // Helper to get source type label
  const getSourceTypeLabel = (type: string | undefined): string => {
    switch (type) {
      case "notion":
        return "Notion";
      case "local":
        return "CSV";
      case "postgresql":
        return "PostgreSQL";
      default:
        return "Unknown";
    }
  };

  // Resolve joined table metadata for display + chart ranking
  // Looks up joined tables via useDataTables hook
  const joinTableDetails = useMemo(
    () =>
      (insight.joins ?? []).map((join, index) => {
        // Look up the joined table from allDataTables
        const joinTable = allDataTables.find((t) => t.id === join.rightTableId);

        // Find the data source for this joined table
        const joinSource = joinTable
          ? dataSources?.find((s) => s.id === joinTable.dataSourceId)
          : undefined;

        // Get fields from the joined table (filter out internal fields)
        const joinFields: LocalField[] = (joinTable?.fields ?? []).filter(
          (f) => !f.name.startsWith("_"),
        );

        // Find base field by leftKey (column name)
        const baseField = fields.find(
          (f) => (f.columnName ?? f.name) === join.leftKey,
        );

        return {
          id: `join-${index}` as UUID, // Synthetic ID based on index
          tableId: join.rightTableId,
          joinType: join.type,
          joinTable,
          joinSource,
          joinFields,
          baseFieldName: baseField?.name ?? join.leftKey ?? "Base field",
          joinedFieldName: join.rightKey ?? "Joined field",
          tableName: joinTable?.name ?? "Joined table",
          rowCount: 0, // Could be computed if needed
          fieldCount: joinFields.length,
          sourceType: getSourceTypeLabel(joinSource?.type),
          leftKey: join.leftKey,
          rightKey: join.rightKey,
        };
      }),
    [insight.joins, allDataTables, dataSources, fields],
  );

  // Fields to display in Join preview
  // Combines fields from base table + all joined tables
  const previewFields = useMemo(() => {
    // Start with base table fields
    const combined: Array<LocalField & { _isJoined?: boolean }> =
      allTableFields.map((f) => ({
        ...f,
        _isJoined: false,
      }));

    // Add fields from all joined tables
    if (insight.joins?.length && joinTableDetails.length > 0) {
      // Collect all joined fields into a flat array first
      const allJoinedFields = joinTableDetails.flatMap((join) =>
        join.joinFields.map((field: LocalField) => field),
      );
      // Then add non-duplicate fields to combined
      for (const field of allJoinedFields) {
        const fieldName = field.columnName ?? field.name;
        const exists = combined.some(
          (f) => (f.columnName ?? f.name) === fieldName,
        );
        if (!exists) {
          combined.push({
            ...field,
            _isJoined: true,
          });
        }
      }
    }

    return combined;
  }, [allTableFields, insight.joins, joinTableDetails]);

  // Effect to compute joined data using DuckDB when joins exist
  useEffect(() => {
    if (!insight.joins?.length) {
      setJoinedPreviewData(null);
      return;
    }

    if (!duckDBConnection || !isDuckDBReady) {
      return;
    }

    if (!dataTable?.dataFrameId) {
      return;
    }

    // Wait for base table to be loaded into DuckDB (via pagination hook)
    // This prevents "Table does not exist" errors from race conditions
    if (!isPreviewReady) {
      return;
    }

    const computeJoinedData = async () => {
      setIsLoadingJoinedData(true);

      // dataTable.dataFrameId is verified non-null by the guard above
      const baseDataFrameId = dataTable.dataFrameId!;

      try {
        // Base table should already be loaded by useDataFramePagination
        const baseDataFrame = getDataFrame(baseDataFrameId);
        if (!baseDataFrame) {
          console.error("Base DataFrame not found");
          setIsLoadingJoinedData(false);
          return;
        }

        // Base table is already loaded via useDataFramePagination (isPreviewReady guard)
        const baseTableName = `df_${baseDataFrameId.replace(/-/g, "_")}`;

        // Get base column names
        const baseColNames = fields
          .filter((f) => !f.name.startsWith("_"))
          .map((f) => f.columnName ?? f.name);

        // Process each join
        let currentTableSQL = baseTableName;
        const allJoinColNames = new Set<string>();

        // Get base table display name for column prefixing (cleaned of UUIDs)
        const baseDisplayName = shortenAutoGeneratedName(dataTable.name);

        for (
          let joinIdx = 0;
          joinIdx < (insight.joins ?? []).length;
          joinIdx++
        ) {
          const join = insight.joins![joinIdx];
          const joinDetail = joinTableDetails[joinIdx];
          if (!joinDetail?.joinTable?.dataFrameId) continue;

          // Load join table into DuckDB
          const joinDataFrame = getDataFrame(joinDetail.joinTable.dataFrameId);
          if (!joinDataFrame) continue;

          // Load and trigger ensureLoaded() by calling sql() on the QueryBuilder
          const joinQueryBuilder = await (joinDataFrame as any).load(
            duckDBConnection,
          );
          await joinQueryBuilder.sql(); // This triggers the actual table creation in DuckDB
          const joinTableName = `df_${joinDetail.joinTable.dataFrameId.replace(/-/g, "_")}`;

          // Get join table display name for column prefixing (cleaned of UUIDs)
          const joinDisplayName = shortenAutoGeneratedName(
            joinDetail.joinTable.name,
          );

          // Get join column info using leftKey/rightKey column names directly
          const leftColName = join.leftKey;
          const rightColName = join.rightKey;

          if (!leftColName || !rightColName) continue;

          // Get column lists from join table
          const joinColNames = joinDetail.joinFields
            .filter((f: LocalField) => !f.name.startsWith("_"))
            .map((f: LocalField) => f.columnName ?? f.name);

          // Build SELECT clause with table name prefixes for duplicates
          const selectParts: string[] = [];

          for (const col of baseColNames) {
            const isDuplicate =
              joinColNames.includes(col) && col !== leftColName;
            if (isDuplicate) {
              // Use table name prefix: "accounts.acctid" instead of "acctid_base"
              selectParts.push(`base."${col}" AS "${baseDisplayName}.${col}"`);
            } else {
              selectParts.push(`base."${col}"`);
            }
          }

          // Build lowercase set of base column names for case-insensitive duplicate detection
          const baseColNamesLower = new Set(
            baseColNames.map((c) => c.toLowerCase()),
          );

          for (const col of joinColNames) {
            // Check for duplicate using case-insensitive comparison
            // DuckDB treats column names case-insensitively, so "acctId" and "acctid" conflict
            const isDuplicate = baseColNamesLower.has(col.toLowerCase());
            if (isDuplicate) {
              // Use table name prefix: "opportunities.acctid" instead of "acctid_1"
              const prefixedName = `${joinDisplayName}.${col}`;
              selectParts.push(`j."${col}" AS "${prefixedName}"`);
              allJoinColNames.add(prefixedName);
            } else {
              selectParts.push(`j."${col}"`);
              allJoinColNames.add(col);
            }
          }

          const joinTypeSQL = (join.type ?? "inner").toUpperCase();

          currentTableSQL = `(
            SELECT ${selectParts.join(", ")}
            FROM ${currentTableSQL} AS base
            ${joinTypeSQL} JOIN ${joinTableName} AS j
            ON base."${leftColName}" = j."${rightColName}"
          )`;
        }

        // Get total count
        const countSQL = `SELECT COUNT(*) as count FROM ${currentTableSQL}`;
        const countResult = await duckDBConnection.query(countSQL);
        const totalCount = Number(countResult.toArray()[0]?.count ?? 0);

        // Get all rows for chart suggestions and aggregation preview
        const sampleSQL = `SELECT * FROM ${currentTableSQL}`;
        console.log("[InsightConfigureTab] Join SQL:", currentTableSQL);
        const sampleResult = await duckDBConnection.query(sampleSQL);
        const sampleRows = sampleResult.toArray() as DataFrameRow[];

        // Build columns from result
        const columns =
          sampleRows.length > 0
            ? Object.keys(sampleRows[0])
                .filter((key) => !key.startsWith("_"))
                .map((name) => ({
                  name,
                  _isJoined: allJoinColNames.has(name),
                }))
            : [];

        // Store SQL for async pagination + sample rows for suggestions
        setJoinedPreviewData({
          sql: currentTableSQL,
          columns,
          totalCount,
          sampleRows,
        });
      } catch (err) {
        console.error("Failed to compute joined data:", err);
        setJoinedPreviewData(null);
      } finally {
        setIsLoadingJoinedData(false);
      }
    };

    computeJoinedData();
  }, [
    insight.joins,
    duckDBConnection,
    isDuckDBReady,
    dataTable?.dataFrameId,
    dataTable.name,
    fields,
    joinTableDetails,
    isPreviewReady,
  ]);

  // Async fetch callback for joined data pagination
  const fetchJoinedData = useCallback(
    async (params: FetchDataParams): Promise<FetchDataResult> => {
      if (!joinedPreviewData?.sql || !duckDBConnection || !isDuckDBReady) {
        return { rows: [], totalCount: 0 };
      }

      try {
        let sql = joinedPreviewData.sql;

        // Apply sorting if specified
        if (params.sortColumn && params.sortDirection) {
          sql = `SELECT * FROM (${sql}) ORDER BY "${params.sortColumn}" ${params.sortDirection.toUpperCase()}`;
        }

        // Apply pagination
        sql = `SELECT * FROM (${sql}) LIMIT ${params.limit} OFFSET ${params.offset}`;

        const result = await duckDBConnection.query(sql);
        const rows = result.toArray() as DataFrameRow[];

        return { rows, totalCount: joinedPreviewData.totalCount };
      } catch (err) {
        console.error("Failed to fetch joined data page:", err);
        return { rows: [], totalCount: 0 };
      }
    },
    [joinedPreviewData, duckDBConnection, isDuckDBReady],
  );

  // Compute selected fields (for configured state)
  // Filters previewFields by the IDs stored in insight.selectedFields
  const selectedFields = useMemo(() => {
    const selectedIds = insight.selectedFields ?? [];
    if (selectedIds.length === 0) return [];
    return previewFields.filter(
      (f) => selectedIds.includes(f.id) && !f.name.startsWith("_"),
    );
  }, [previewFields, insight.selectedFields]);

  // Map columns to their originating table for multi-table chart ranking
  const columnTableMap = useMemo<Record<string, UUID[]>>(() => {
    const map: Record<string, UUID[]> = {};
    const addMapping = (columnName: string | undefined, tableId: UUID) => {
      if (!columnName) return;
      const existing = map[columnName] ?? [];
      if (!existing.includes(tableId)) {
        map[columnName] = [...existing, tableId];
      }
    };

    fields.forEach((field) => {
      if (field.name.startsWith("_")) return;
      const name = field.columnName ?? field.name;
      addMapping(name, dataTable.id);
      addMapping(`${name}_base`, dataTable.id); // Join suffix coverage
    });

    joinTableDetails.forEach((joinDetail) => {
      const tableId = joinDetail.joinTable?.id ?? joinDetail.tableId;
      joinDetail.joinFields.forEach((field) => {
        if (field.name.startsWith("_")) return;
        const name = field.columnName ?? field.name;
        addMapping(name, tableId);
        addMapping(`${name}_join`, tableId);
      });
    });

    return map;
  }, [fields, dataTable.id, joinTableDetails]);

  // Compute visible metrics
  const visibleMetrics = useMemo(() => {
    return insightMetrics.filter((m) => !m.name.startsWith("_"));
  }, [insightMetrics]);

  // Determine which DataFrame to display:
  // NOTE: dataFrameId was removed from Insight - always use base table's DataFrame
  // Computed results are now stored in joinedPreviewData state
  const activeDataFrameId = dataTable?.dataFrameId;

  // Compute DuckDB table name for chart rendering
  const suggestionTableName = useMemo(() => {
    if (!activeDataFrameId) return null;
    return `df_${activeDataFrameId.replace(/-/g, "_")}`;
  }, [activeDataFrameId]);

  // Raw preview for unconfigured state (shows source data directly)
  const rawPreview = useMemo(() => {
    if (isConfigured) return null;
    if (!sourceDataFrameData) return null;

    return {
      dataFrame: {
        columns: sourceDataFrameData.columns,
        rows: sourceDataFrameData.rows,
      },
      rowCount: sourceDataFrameData.rows.length,
    };
  }, [isConfigured, sourceDataFrameData]);

  // Aggregated preview for configured state
  // NOTE: This is computed AFTER onDemandJoinPreview is available, but we can't use it
  // directly here due to hook ordering. We'll compute aggregation separately below.
  const aggregatedPreview = useMemo<PreviewResult | null>(() => {
    if (!isConfigured) return null;
    if (!dataTable?.dataFrameId) return null;
    if (!sourceDataFrameData) return null;

    try {
      // Convert local types to expected format for compute function
      const insightForCompute = {
        id: insightId,
        name: insight.name,
        baseTable: {
          tableId: dataTable.id,
          selectedFields: insight.selectedFields || [],
        },
        metrics: insightMetrics.map((m) => ({
          id: m.id,
          name: m.name,
          sourceTable: m.sourceTable,
          columnName: m.columnName,
          aggregation: m.aggregation,
        })),
        filters: insight.filters,
        createdAt: insight.createdAt,
        updatedAt: insight.updatedAt,
      };

      const dataTableForCompute = {
        id: dataTable.id,
        name: dataTable.name,
        table: dataTable.table,
        dataFrameId: dataTable.dataFrameId,
        fields: fields.map((f) => ({
          id: f.id,
          name: f.name,
          columnName: f.columnName,
          type: f.type,
        })),
      };

      // Use source data directly (DataFrameData format)
      const sourceDataForCompute = {
        columns: sourceDataFrameData.columns,
        rows: sourceDataFrameData.rows,
      };

      // Use Infinity for maxRows to compute all aggregated groups (not just first 50)
      return computeInsightPreview(
        insightForCompute as any,
        dataTableForCompute as any,
        sourceDataForCompute,
        Infinity,
      );
    } catch (error) {
      console.error("Failed to compute preview:", error);
      return null;
    }
  }, [
    isConfigured,
    insight,
    insightId,
    dataTable,
    fields,
    insightMetrics,
    sourceDataFrameData,
  ]);

  // Use appropriate preview based on state
  const preview = isConfigured ? aggregatedPreview : rawPreview;

  // Join preview data - computed ON-DEMAND from source tables using join config
  // This ensures we always show raw joined data, not aggregated data
  // Returns displayRows (limited for HTML table) and allRows (full data for aggregations)
  const onDemandJoinPreview = useMemo(() => {
    // Get base table DataFrame
    if (!dataTable?.dataFrameId) return null;
    if (!sourceDataFrameData) return null;

    // Helper to build columns from fields
    const buildColumnsFromFields = (
      tableFields: LocalField[],
    ): DataFrameColumn[] => {
      return tableFields
        .filter((f) => !f.name.startsWith("_"))
        .map((f) => ({
          name: f.columnName ?? f.name,
          type: f.type,
        }));
    };

    // If no joins, just return base table data
    if (!insight.joins?.length) {
      const baseColumns: DataFrameColumn[] =
        sourceDataFrameData.columns ?? buildColumnsFromFields(fields);
      const columns = baseColumns
        .filter((col: DataFrameColumn) => !col.name.startsWith("_"))
        .map((col: DataFrameColumn) => ({
          id: col.name,
          name: col.name,
          columnName: col.name,
          type: col.type,
          _isJoined: false,
        }));

      return {
        columns,
        rows: sourceDataFrameData.rows,
        allRows: sourceDataFrameData.rows,
        rowCount: sourceDataFrameData.rows.length,
      };
    }

    // Build base columns first
    const baseColumns = (
      sourceDataFrameData.columns ?? buildColumnsFromFields(fields)
    )
      .filter((col: DataFrameColumn) => !col.name.startsWith("_"))
      .map((col: DataFrameColumn) => ({
        id: col.name,
        name: col.name,
        columnName: col.name,
        type: col.type,
        _isJoined: false,
      }));

    // NOTE: Client-side joins have been removed. Joins are now computed via DuckDB SQL.
    // For now, when joins exist, we show base columns + join columns (without actual join computation).
    // NOTE: Implement DuckDB-based join preview using QueryBuilder (tracked separately)
    if (insight.joins.length > 0) {
      // Collect all join table columns for display
      const allJoinColumns: typeof baseColumns = [];
      for (let joinIdx = 0; joinIdx < insight.joins.length; joinIdx++) {
        const joinDetail = joinTableDetails[joinIdx];
        if (!joinDetail) continue;

        for (const field of joinDetail.joinFields) {
          allJoinColumns.push({
            id: field.id,
            name: field.name,
            columnName: field.columnName ?? field.name,
            type: field.type,
            _isJoined: true,
          });
        }
      }

      // Return base columns + join columns (without actual join computation)
      return {
        columns: [...baseColumns, ...allJoinColumns],
        rows: sourceDataFrameData.rows,
        allRows: sourceDataFrameData.rows,
        rowCount: sourceDataFrameData.rows.length,
      };
    }

    // No joins - return base table data
    return {
      columns: baseColumns,
      rows: sourceDataFrameData.rows,
      allRows: sourceDataFrameData.rows,
      rowCount: sourceDataFrameData.rows.length,
    };
  }, [
    dataTable?.dataFrameId,
    sourceDataFrameData,
    fields,
    insight.joins,
    joinTableDetails,
  ]);

  // Use the on-demand computed columns for join preview
  const joinPreviewColumns = onDemandJoinPreview?.columns ?? previewFields;

  // Compute aggregated result using the DuckDB-computed joined data
  // This properly handles joined column names (with table prefixes like tablename.column)
  const joinedAggregatedPreview = useMemo<PreviewResult | null>(() => {
    if (!isConfigured) return null;
    if (!joinedPreviewData) return null;

    // Get the selected fields
    const selectedFieldIds = insight.selectedFields ?? [];
    if (selectedFieldIds.length === 0) return null;

    // Map selected field IDs to actual column names from the DuckDB join result
    // We need to match field IDs to the new column names which may have table prefixes
    const selectedColumns: Array<{ name: string; type: string }> = [];

    for (const fieldId of selectedFieldIds) {
      // First check base table fields
      const baseField = fields.find((f) => f.id === fieldId);
      if (baseField) {
        const colName = baseField.columnName ?? baseField.name;
        // Check if this column exists in joinedPreviewData (might be prefixed)
        const matchingCol = joinedPreviewData.columns.find(
          (c) => c.name === colName || c.name.endsWith(`.${colName}`),
        );
        if (matchingCol) {
          selectedColumns.push({
            name: matchingCol.name,
            type: matchingCol.type ?? "unknown",
          });
          continue;
        }
      }

      // Check joined table fields
      for (const joinDetail of joinTableDetails) {
        const joinField = joinDetail.joinFields.find(
          (f: LocalField) => f.id === fieldId,
        );
        if (joinField) {
          const colName = joinField.columnName ?? joinField.name;
          // Check if this column exists in joinedPreviewData (might be prefixed with table name)
          const matchingCol = joinedPreviewData.columns.find(
            (c) => c.name === colName || c.name.endsWith(`.${colName}`),
          );
          if (matchingCol) {
            selectedColumns.push({
              name: matchingCol.name,
              type: matchingCol.type ?? "unknown",
            });
            break;
          }
        }
      }
    }

    if (selectedColumns.length === 0) return null;

    // Group rows by selected columns - using the preview rows (limited to 100)
    // Note: For accurate aggregation, this should be computed in DuckDB
    const groupMap = new Map<string, Record<string, unknown>[]>();
    for (const row of joinedPreviewData.sampleRows) {
      const keyParts = selectedColumns.map((col) => {
        const value = row[col.name];
        return value != null ? String(value) : "__NULL__";
      });
      const key = keyParts.join("|||");
      if (!groupMap.has(key)) {
        groupMap.set(key, []);
      }
      groupMap.get(key)!.push(row);
    }

    // Compute aggregations for each group
    const aggregatedRows: Record<string, unknown>[] = [];
    for (const [, groupRows] of groupMap) {
      const row: Record<string, unknown> = {};

      // Add group key values
      for (const col of selectedColumns) {
        row[col.name] = groupRows[0][col.name];
      }

      // Compute metrics
      for (const metric of insightMetrics) {
        if (metric.name.startsWith("_")) continue;

        // Find the actual column name in the joined data
        // The metric.columnName might need table prefix matching
        let actualColumnName: string | undefined = metric.columnName;

        // Check for exact match or table-prefixed match
        const matchingCol = joinedPreviewData.columns.find(
          (c) =>
            c.name === metric.columnName ||
            c.name.endsWith(`.${metric.columnName}`),
        );

        if (matchingCol) {
          actualColumnName = matchingCol.name;
        }

        let value = 0;
        switch (metric.aggregation) {
          case "count":
            value = groupRows.length;
            break;
          case "count_distinct":
            if (actualColumnName) {
              const values = groupRows
                .map((r) => r[actualColumnName])
                .filter((v) => v != null);
              value = new Set(values).size;
            }
            break;
          case "sum":
            if (actualColumnName) {
              value = groupRows.reduce((sum, r) => {
                const val = r[actualColumnName];
                return sum + (typeof val === "number" ? val : 0);
              }, 0);
            }
            break;
          case "avg":
            if (actualColumnName) {
              const values = groupRows
                .map((r) => r[actualColumnName])
                .filter((v) => typeof v === "number") as number[];
              value =
                values.length > 0
                  ? values.reduce((sum, v) => sum + v, 0) / values.length
                  : 0;
            }
            break;
          case "min":
            if (actualColumnName) {
              const values = groupRows
                .map((r) => r[actualColumnName])
                .filter((v) => typeof v === "number") as number[];
              value =
                values.length > 0
                  ? values.reduce((a, b) => (a < b ? a : b), Infinity)
                  : 0;
            }
            break;
          case "max":
            if (actualColumnName) {
              const values = groupRows
                .map((r) => r[actualColumnName])
                .filter((v) => typeof v === "number") as number[];
              value =
                values.length > 0
                  ? values.reduce((a, b) => (a > b ? a : b), -Infinity)
                  : 0;
            }
            break;
        }
        row[metric.name] = value;
      }

      aggregatedRows.push(row);
    }

    // Build columns for the result
    const resultColumns: Array<{
      name: string;
      type: "string" | "number" | "boolean" | "date" | "unknown";
    }> = [
      ...selectedColumns.map((col) => ({
        name: col.name,
        type: col.type as "string" | "number" | "boolean" | "date" | "unknown",
      })),
      ...insightMetrics
        .filter((m) => !m.name.startsWith("_"))
        .map((m) => ({ name: m.name, type: "number" as const })),
    ];

    return {
      dataFrame: {
        columns: resultColumns,
        rows: aggregatedRows,
      },
      rowCount: aggregatedRows.length,
      sampleSize: aggregatedRows.length,
    };
  }, [
    isConfigured,
    joinedPreviewData,
    insight.selectedFields,
    fields,
    joinTableDetails,
    insightMetrics,
  ]);

  // Use joined aggregation when we have joins, otherwise use base table aggregation
  const effectiveAggregatedPreview = insight.joins?.length
    ? joinedAggregatedPreview
    : aggregatedPreview;

  // Use joined preview row count when joins exist, otherwise use DuckDB pagination count
  // Now uses DuckDB-computed counts for accurate row counts without loading all data into RAM
  const rowCount = insight.joins?.length
    ? (joinedPreviewData?.totalCount ?? 0)
    : previewTotalCount;
  const columnCount =
    (insight.joins?.length ? joinPreviewColumns.length : previewFields.length) +
    visibleMetrics.length;

  // Build field map from preview fields (use joined columns when joins exist)
  const fieldMap = useMemo<Record<string, LocalField>>(() => {
    const map: Record<string, LocalField> = {};

    // Use DuckDB-computed joined columns when available, otherwise use previewFields
    if (insight.joins?.length && joinedPreviewData) {
      // For joined data, we need to map back to original fields to get metadata
      // or rely on what we have.
      // joinedPreviewData.columns only has name and type.
      // We try to find the matching field in previewFields.
      joinedPreviewData.columns.forEach((col) => {
        const matchingField = previewFields.find(
          (f) => (f.columnName ?? f.name) === col.name,
        );
        map[col.name] = matchingField || {
          id: col.name as UUID,
          name: col.name,
          tableId: dataTable.id, // Required by Field type
          columnName: col.name,
          type: (col.type as ColumnType) || "string",
        };
      });
    } else {
      previewFields.forEach((f) => {
        map[f.name] = f;
      });
    }

    return map;
  }, [previewFields, joinedPreviewData, insight.joins?.length, dataTable.id]);

  // Effect to run deep analysis using DuckDB when data changes
  useEffect(() => {
    if (!duckDBConnection || !isDuckDBReady) return;
    if (!dataTable?.dataFrameId) return;
    // Wait for data to be ready
    if (insight.joins?.length && !joinedPreviewData) return;
    if (!insight.joins?.length && !isPreviewReady) return;

    const runAnalysis = async () => {
      let tempViewName: string | null = null;

      try {
        let targetTable = "";

        if (insight.joins?.length && joinedPreviewData?.sql) {
          // Create view for joined data
          tempViewName = `v_analysis_${crypto.randomUUID().replace(/-/g, "")}`;
          await duckDBConnection.query(
            `CREATE OR REPLACE TEMP VIEW "${tempViewName}" AS ${joinedPreviewData.sql}`,
          );
          targetTable = tempViewName;
        } else {
          // Use base table
          targetTable = `df_${dataTable.dataFrameId!.replace(/-/g, "_")}`;
        }

        console.debug("[Analysis] Starting analysis", {
          targetTable,
          hasJoins: !!insight.joins?.length,
          previewFieldsCount: previewFields.length,
          joinPreviewColumnsCount: joinPreviewColumns.length,
        });

        // Prepare columns list
        // For non-join cases, use previewFields directly (doesn't depend on sourceDataFrameData)
        // For join cases, use joinPreviewColumns (from joinedPreviewData)
        let colsToAnalyze: DataFrameColumn[];
        if (insight.joins?.length && joinedPreviewData) {
          // Join case: use columns from joined preview data
          if (joinPreviewColumns.length > 0) {
            colsToAnalyze = joinPreviewColumns.map((c) => ({
              name: c.columnName ?? c.name,
              type: c.type as any,
            }));
          } else {
            // Fallback: query DuckDB for column names
            const quotedTable = `"${targetTable}"`;
            const sampleResult = await duckDBConnection.query(
              `SELECT * FROM ${quotedTable} LIMIT 1`,
            );
            const sampleRows = sampleResult.toArray() as Record<
              string,
              unknown
            >[];
            if (sampleRows.length > 0) {
              const columnNames = Object.keys(sampleRows[0]).filter(
                (name) => !name.startsWith("_"),
              );
              colsToAnalyze = columnNames.map((name) => ({
                name,
                type: "unknown" as any,
              }));
            } else {
              colsToAnalyze = [];
            }
          }
        } else {
          // Non-join case: use previewFields directly (from fields prop, doesn't need sourceDataFrameData)
          if (previewFields.length === 0) {
            // Fallback: query DuckDB for column names if previewFields is empty
            const quotedTable = `"${targetTable}"`;
            const sampleResult = await duckDBConnection.query(
              `SELECT * FROM ${quotedTable} LIMIT 1`,
            );
            const sampleRows = sampleResult.toArray() as Record<
              string,
              unknown
            >[];
            if (sampleRows.length > 0) {
              const columnNames = Object.keys(sampleRows[0]).filter(
                (name) => !name.startsWith("_"),
              );
              colsToAnalyze = columnNames.map((name) => ({
                name,
                type: "unknown" as any,
              }));
            } else {
              colsToAnalyze = [];
            }
          } else {
            colsToAnalyze = previewFields
              .filter((f) => !f.name.startsWith("_"))
              .map((f) => ({
                name: f.columnName ?? f.name,
                type: f.type as any,
              }));
          }
        }

        console.debug("[Analysis] Columns to analyze", {
          count: colsToAnalyze.length,
          columns: colsToAnalyze.map((c) => ({ name: c.name, type: c.type })),
        });

        // Skip analysis if no columns to analyze
        if (colsToAnalyze.length === 0) {
          console.warn("[Analysis] No columns to analyze, skipping");
          setColumnAnalysis([]);
          return;
        }

        // Run analysis
        const results = await analyzeDataFrame(
          duckDBConnection,
          targetTable,
          colsToAnalyze,
        );

        console.debug("[Analysis] Completed", {
          columnCount: results.length,
          columns: results.map((r) => r.columnName),
          tableName: targetTable,
        });

        setColumnAnalysis(results);
      } catch (e) {
        console.error("[InsightConfigureTab] Analysis failed:", e);
      } finally {
        if (tempViewName) {
          try {
            await duckDBConnection.query(
              `DROP VIEW IF EXISTS "${tempViewName}"`,
            );
          } catch {
            /* ignore */
          }
        }
      }
    };

    runAnalysis();
    // eslint-disable-next-line react-hooks/exhaustive-deps -- Intentionally using subsets (sql, length) instead of full objects to avoid re-runs on irrelevant changes
  }, [
    duckDBConnection,
    isDuckDBReady,
    joinedPreviewData?.sql ?? null, // Use null instead of undefined to keep array size constant
    dataTable?.dataFrameId ?? null, // Use null instead of undefined to keep array size constant
    insight.joins?.length ?? 0, // Use 0 instead of undefined to keep array size constant
    isPreviewReady,
    // For non-join cases: previewFields comes from fields prop (always available)
    // For join cases: joinedPreviewData?.sql change triggers re-analysis
    // This allows analysis to run even when sourceDataFrameData hasn't loaded yet
    previewFields.length, // Use previewFields as a stable dependency for non-join cases
  ]);

  // Generate chart suggestions (only for unconfigured state)
  // Uses DuckDB-computed analysis results - no need to load all data into RAM
  const suggestions = useMemo<ChartSuggestion[]>(() => {
    // Check if we have joins and DuckDB-computed joined preview data
    const hasJoins = !!(insight.joins?.length && joinedPreviewData);

    // Skip suggestions if insight is already configured
    if (isConfigured) return [];

    // For non-join cases, ensure table is loaded into DuckDB (isPreviewReady)
    // For join cases, ensure joined data is computed
    if (!hasJoins && !isPreviewReady) return [];
    if (hasJoins && !joinedPreviewData) return [];

    // Check if analysis is ready (computed via DuckDB SQL)
    if (columnAnalysis.length === 0) {
      console.debug("[Suggestions] Waiting for column analysis...", {
        columnAnalysisLength: columnAnalysis.length,
        isPreviewReady,
        hasJoins,
        joinedPreviewData: !!joinedPreviewData,
      });
      return [];
    }

    // Check if we have data (rowCount > 0)
    if (rowCount === 0) {
      console.debug("[Suggestions] No data rows available", { rowCount });
      return [];
    }

    try {
      // Create a minimal insight object for suggestions
      const insightForSuggestions = {
        id: insightId,
        name: insight.name,
        baseTable: {
          tableId: dataTable.id,
          selectedFields: [] as string[],
        },
        metrics: [] as any[],
        createdAt: insight.createdAt,
        updatedAt: insight.updatedAt,
      };

      // Log column analysis details for debugging
      console.debug("[Suggestions] Column analysis details", {
        columnCount: columnAnalysis.length,
        columns: columnAnalysis.map((col) => ({
          name: col.columnName,
          category: col.category,
          cardinality: col.cardinality,
          nullCount: col.nullCount,
          min: col.min,
          max: col.max,
        })),
        rowCount,
        fieldMapKeys: Object.keys(fieldMap),
      });

      // suggestCharts now accepts ColumnAnalysis[] and rowCount
      // It no longer needs the raw data rows for variance checks (uses SQL stats)
      const result = suggestCharts(
        insightForSuggestions as any,
        columnAnalysis,
        rowCount,
        fieldMap as any,
        3,
        columnTableMap,
        suggestionSeed,
      );

      console.debug("[Suggestions] Generated suggestions", {
        count: result.length,
        columnAnalysisCount: columnAnalysis.length,
        rowCount,
        hasJoins,
        suggestions: result.map((s) => ({ type: s.chartType, title: s.title })),
      });

      return result;
    } catch (error) {
      console.error("Failed to generate suggestions:", error);
      return [];
    }
  }, [
    isConfigured,
    joinedPreviewData,
    insight,
    insightId,
    fieldMap,
    dataTable,
    columnTableMap,
    suggestionSeed,
    columnAnalysis,
    rowCount,
    isPreviewReady,
  ]);

  // Get data source type label
  const dataSourceTypeLabel = useMemo(() => {
    if (!dataSource?.type) return "unknown source";
    switch (dataSource.type) {
      case "notion":
        return "Notion database";
      case "local":
        return "Uploaded CSV";
      case "postgresql":
        return "PostgreSQL source";
      default:
        return "unknown source";
    }
  }, [dataSource]);

  // Parse aggregate expression like "sum(amount)" â†’ { aggregation: "sum", columnName: "amount" }
  const parseAggregateExpression = (
    expr: string,
  ): {
    aggregation: InsightMetric["aggregation"];
    columnName: string;
  } | null => {
    const match = expr.match(
      /^(sum|avg|count|min|max|count_distinct)\(([^)]+)\)$/i,
    );
    if (match) {
      return {
        aggregation: match[1].toLowerCase() as InsightMetric["aggregation"],
        columnName: match[2],
      };
    }
    return null;
  };

  // Handle creating a chart from suggestion (LOCAL ONLY - no Convex)
  const handleCreateChart = async (suggestion: ChartSuggestion) => {
    if (!activeDataFrameId) return;
    if (!sourceDataFrameData) return;

    // Parse encoding to determine fields and metrics for the insight
    const encoding = suggestion.encoding;
    const dimensionFields: string[] = []; // Column names to group by
    const metrics: InsightMetric[] = [];

    // Process X axis - check if it's a dimension or aggregate
    if (encoding.x) {
      const parsed = parseAggregateExpression(encoding.x);
      if (parsed) {
        // X is an aggregate (rare but possible)
        const metricId = crypto.randomUUID();
        metrics.push({
          id: metricId,
          name: encoding.x, // e.g., "sum(amount)"
          sourceTable: dataTable.id,
          columnName: parsed.columnName,
          aggregation: parsed.aggregation,
        });
      } else {
        // X is a dimension field
        dimensionFields.push(encoding.x);
      }
    }

    // Process Y axis - commonly an aggregate like "sum(amount)"
    if (encoding.y) {
      const parsed = parseAggregateExpression(encoding.y);
      if (parsed) {
        // Y is an aggregate - add as metric
        const metricId = crypto.randomUUID();
        metrics.push({
          id: metricId,
          name: encoding.y, // e.g., "sum(amount)"
          sourceTable: dataTable.id,
          columnName: parsed.columnName,
          aggregation: parsed.aggregation,
        });
      } else {
        // Y is a dimension (for scatter plots, etc.)
        dimensionFields.push(encoding.y);
      }
    }

    // Process color - typically a dimension
    if (encoding.color) {
      const parsed = parseAggregateExpression(encoding.color);
      if (!parsed) {
        dimensionFields.push(encoding.color);
      }
    }

    // Map dimension column names to field IDs
    // For joined data, we need to find fields by column name
    const fieldIdMap = new Map<string, UUID>();

    // Build field map from previewFields (which include joined columns)
    previewFields.forEach((f) => {
      fieldIdMap.set(f.columnName ?? f.name, f.id);
    });

    // Also add fields from the original dataTable for base table columns
    fields.forEach((f) => {
      if (!fieldIdMap.has(f.columnName ?? f.name)) {
        fieldIdMap.set(f.columnName ?? f.name, f.id);
      }
    });

    // Convert dimension column names to field IDs
    const selectedFieldIds = dimensionFields
      .map((colName) => fieldIdMap.get(colName))
      .filter((id): id is UUID => id !== undefined);

    // Now configure the insight with the extracted fields and metrics
    // This triggers the proper data flow where insight knows about the configuration
    updateInsightLocal(insightId, {
      selectedFields: selectedFieldIds,
      metrics: metrics,
    });

    // Compute the aggregated DataFrame
    // Build proper insight object for computation
    const computeInsight = {
      id: insightId,
      name: insight.name,
      baseTable: {
        tableId: dataTable.id,
        selectedFields: selectedFieldIds,
      },
      metrics: metrics.map((m) => ({
        id: m.id,
        name: m.name,
        sourceTable: m.sourceTable,
        columnName: m.columnName,
        aggregation: m.aggregation,
      })),
      filters: insight.filters,
      createdAt: insight.createdAt,
      updatedAt: insight.updatedAt,
    };

    const computeDataTable = {
      id: dataTable.id,
      name: dataTable.name,
      table: dataTable.table,
      dataFrameId: activeDataFrameId,
      fields: previewFields.map((f) => ({
        id: f.id,
        name: f.name,
        columnName: f.columnName ?? f.name,
        type: f.type,
      })),
    };

    // Compute aggregated data using source DataFrameData
    const sourceDataForCompute = {
      columns: sourceDataFrameData.columns,
      rows: sourceDataFrameData.rows,
    };
    const aggregatedData = computeInsightDataFrame(
      computeInsight as any,
      computeDataTable as any,
      sourceDataForCompute,
    );

    console.log("Computed aggregated data:", {
      rows: aggregatedData.rows.length,
      columns: aggregatedData.columns?.length ?? 0,
    });

    // Create visualization using encoding-driven rendering
    // Architecture:
    // - Source DataFrame: Raw data stored in IndexedDB, loaded into DuckDB
    // - Insight: Configuration for dimensions, metrics, filters
    // - Visualization: Points to insight, renders via encoding (spec deprecated)
    // Note: Empty spec passed for backward compatibility; rendering now uses encoding
    const vizId = await createVisualizationLocal(
      suggestion.title,
      insightId,
      suggestion.chartType,
      {} as VegaLiteSpec, // Deprecated: rendering now uses encoding
      suggestion.encoding,
    );

    // Navigate to the visualization using route-based navigation
    router.push(`/visualizations/${vizId}`);
  };

  // Add a field from column header click
  const handleAddField = (columnName: string) => {
    // Find field by column name
    const field = fields.find((f) => (f.columnName ?? f.name) === columnName);
    if (!field) return;

    // Don't add if already selected
    if (insight.selectedFields?.includes(field.id)) return;

    updateInsightLocal(insightId, {
      selectedFields: [...(insight.selectedFields || []), field.id],
    });
  };

  // Remove a field from the selected list
  const handleRemoveField = (fieldId: UUID) => {
    updateInsightLocal(insightId, {
      selectedFields:
        insight.selectedFields?.filter((id: UUID) => id !== fieldId) || [],
    });
  };

  // Add a metric from column header click
  const handleAddMetric = (
    columnName: string,
    aggregation: InsightMetric["aggregation"],
  ) => {
    const metricId = crypto.randomUUID() as UUID;
    const metricName = `${aggregation}(${columnName})`;

    // Check if metric already exists
    const exists = insightMetrics.some(
      (m) => m.columnName === columnName && m.aggregation === aggregation,
    );
    if (exists) return;

    updateInsightLocal(insightId, {
      metrics: [
        ...(insight.metrics || []),
        {
          id: metricId,
          name: metricName,
          sourceTable: dataTable.id,
          columnName,
          aggregation,
        },
      ],
    });
  };

  // Remove a metric
  const handleRemoveMetric = (metricId: UUID) => {
    updateInsightLocal(insightId, {
      metrics: insight.metrics?.filter((m) => m.id !== metricId) || [],
    });
  };

  // Remove a join from the insight by index
  // NOTE: Joins are now identified by position (index) since the schema no longer has join IDs
  const handleRemoveJoin = useCallback(
    (joinIndex: number) => {
      const updatedJoins =
        insight.joins?.filter((_, idx) => idx !== joinIndex) || [];
      updateInsightLocal(insightId, {
        joins: updatedJoins,
      });

      // If no joins remain, clear the joined preview data
      if (updatedJoins.length === 0) {
        setJoinedPreviewData(null);
      }
    },
    [insight.joins, insightId, updateInsightLocal],
  );

  // Build ItemList items for Data Sources section
  const dataSourceItems = useMemo<ListItem[]>(() => {
    // Get base table metadata from entry (inline lookup)
    const baseDataFrameEntry = dataTable?.dataFrameId
      ? allDataFrameEntries.find((e) => e.id === dataTable.dataFrameId)
      : undefined;
    const baseRowCount = baseDataFrameEntry?.rowCount ?? 0;
    const baseFieldCount = allTableFields.length;

    // Base table item (always first)
    const baseItem: ListItem = {
      id: "base",
      title: dataTable.name,
      subtitle: `${baseRowCount.toLocaleString()} rows â€¢ ${baseFieldCount} fields`,
      badge: "base",
      icon: <Database className="h-4 w-4" />,
    };

    // Join items - show table name prominently, join info in subtitle
    // NOTE: handleRemoveJoin now takes an index, not a UUID
    const joinItems: ListItem[] = joinTableDetails.map((joinDetail, idx) => ({
      id: joinDetail.id,
      title: joinDetail.tableName,
      subtitle: `${joinDetail.baseFieldName} â†’ ${joinDetail.joinedFieldName} â€¢ ${joinDetail.rowCount.toLocaleString()} rows`,
      badge: getJoinTypeLabel(joinDetail.joinType).replace(" join", ""),
      icon: <JoinTypeIcon type={joinDetail.joinType} size="sm" />,
      actions: [
        {
          icon: X,
          label: "Remove",
          variant: "ghost" as const,
          onClick: () => handleRemoveJoin(idx),
        },
      ],
    }));

    return [baseItem, ...joinItems];
  }, [
    dataTable,
    allTableFields,
    allDataFrameEntries,
    joinTableDetails,
    handleRemoveJoin,
  ]);

  const dataSummary = `${rowCount.toLocaleString()} rows â€¢ ${columnCount} fields â€¢ ${visibleMetrics.length} metrics`;

  // Render unconfigured state (draft insight)
  if (!isConfigured) {
    return (
      <div className="flex-1">
        <div className="container mx-auto max-w-6xl space-y-6 px-6 py-6">
          {/* Data Sources Section with ItemList */}
          <section className="border-border bg-card space-y-3 rounded-2xl border p-6 shadow-sm">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-muted-foreground text-xs font-semibold">
                  Data sources
                </p>
                <p className="text-foreground text-sm">
                  Tables used in this insight
                </p>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setIsJoinFlowOpen(true)}
              >
                <Plus className="mr-1 h-4 w-4" />
                Add join
              </Button>
            </div>
            <ItemList
              items={dataSourceItems}
              onSelect={() => {}}
              orientation="horizontal"
              gap={12}
              itemWidth={260}
              emptyMessage="No data sources"
              emptyIcon={<Database className="h-8 w-8" />}
            />
          </section>

          {/* Data Preview Section */}
          <section className="border-border bg-card space-y-4 rounded-2xl border p-6 shadow-sm">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-muted-foreground text-xs font-semibold">
                  Data preview
                </p>
                <p className="text-foreground text-sm">
                  {/* Use joined data count when joins exist, otherwise base table count */}
                  {(insight.joins?.length
                    ? (joinedPreviewData?.totalCount ?? 0)
                    : previewTotalCount || rowCount
                  ).toLocaleString()}{" "}
                  rows
                </p>
              </div>
              <div className="text-muted-foreground flex items-center gap-3 text-xs">
                <span>{dataSummary}</span>
                <span>â€¢</span>
                <span>{dataSourceTypeLabel}</span>
              </div>
            </div>
            {/* Use VirtualTable for efficient rendering of large datasets */}
            {/* Show skeleton while data is loading */}
            {isLoadingSourceData && !isPreviewReady && !preview ? (
              <div
                className="bg-muted/20 relative overflow-hidden rounded-xl border"
                style={{ height: 260 }}
              >
                <div className="bg-muted border-b px-3 py-2">
                  <div className="flex gap-4">
                    {[1, 2, 3, 4].map((i) => (
                      <div
                        key={i}
                        className="bg-muted-foreground/20 h-4 w-24 animate-pulse rounded"
                      />
                    ))}
                  </div>
                </div>
                <div className="space-y-2 p-3">
                  {[1, 2, 3, 4, 5, 6].map((i) => (
                    <div key={i} className="flex gap-4">
                      {[1, 2, 3, 4].map((j) => (
                        <div
                          key={j}
                          className="bg-muted-foreground/10 h-4 w-24 animate-pulse rounded"
                        />
                      ))}
                    </div>
                  ))}
                </div>
              </div>
            ) : insight.joins?.length ? (
              // Joins exist: use DuckDB-computed joined data
              isLoadingJoinedData ? (
                <div
                  className="bg-muted/20 relative overflow-hidden rounded-xl border"
                  style={{ height: 260 }}
                >
                  <div className="flex h-full items-center justify-center">
                    <div className="flex flex-col items-center gap-2">
                      <div className="h-6 w-6 animate-spin rounded-full border-2 border-current border-t-transparent" />
                      <span className="text-muted-foreground text-sm">
                        Computing join...
                      </span>
                    </div>
                  </div>
                </div>
              ) : joinedPreviewData ? (
                <VirtualTable
                  onFetchData={fetchJoinedData}
                  height={260}
                  compact
                />
              ) : (
                <p className="text-muted-foreground text-sm">
                  No data available. The data source may not have been loaded
                  yet.
                </p>
              )
            ) : isPreviewReady ? (
              // No joins: use async mode with DuckDB pagination for full dataset browsing
              <VirtualTable
                onFetchData={fetchPreviewData}
                height={260}
                compact
              />
            ) : preview ? (
              // Fallback to static preview while async mode initializes
              <VirtualTable
                rows={preview.dataFrame.rows}
                columns={preview.dataFrame.columns}
                height={260}
                compact
              />
            ) : (
              <p className="text-muted-foreground text-sm">
                No data available. The data source may not have been loaded yet.
              </p>
            )}
          </section>

          {/* Suggested Charts Section */}
          <section className="space-y-4">
            <div className="flex items-end justify-between">
              <div>
                <h3 className="text-foreground text-lg font-semibold">
                  Suggested charts
                </h3>
              </div>
              <p className="text-muted-foreground text-xs">
                {isLoadingSourceData
                  ? "Analyzing data..."
                  : "Click a suggestion to create a visualization"}
              </p>
            </div>
            {isLoadingSourceData ? (
              // Show skeleton cards while loading
              <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
                {[1, 2, 3].map((i) => (
                  <div
                    key={i}
                    className="border-border bg-card rounded-2xl border p-4 shadow-sm"
                  >
                    <div className="bg-muted mb-3 h-32 animate-pulse rounded-xl" />
                    <div className="bg-muted-foreground/20 mb-2 h-5 w-3/4 animate-pulse rounded" />
                    <div className="bg-muted-foreground/10 h-4 w-1/2 animate-pulse rounded" />
                  </div>
                ))}
              </div>
            ) : suggestionTableName && (isPreviewReady || joinedPreviewData) ? (
              <SuggestedInsights
                tableName={suggestionTableName}
                suggestions={suggestions}
                onCreateChart={handleCreateChart}
                onRegenerate={() => setSuggestionSeed((prev) => prev + 1)}
              />
            ) : null}
          </section>
        </div>

        {/* Sticky Footer Actions */}
        <div className="bg-card/90 sticky bottom-0 border-t px-6 py-4 backdrop-blur-sm">
          <div className="container mx-auto max-w-6xl">
            <div className="flex flex-wrap items-center justify-between gap-3">
              <p className="text-muted-foreground text-xs">
                Need something custom? Build from scratch or join another
                dataset.
              </p>
              <div className="flex gap-3">
                <Button variant="outline" size="sm">
                  Create custom visualization
                </Button>
                <Button size="sm" onClick={() => setIsJoinFlowOpen(true)}>
                  Join with another dataset
                </Button>
              </div>
            </div>
          </div>
        </div>

        <JoinFlowModal
          insight={insight as any}
          dataTable={dataTable as any}
          isOpen={isJoinFlowOpen}
          onOpenChange={setIsJoinFlowOpen}
        />
      </div>
    );
  }

  // Column header dropdown component
  const ColumnHeaderDropdown = ({
    columnName,
    columnType,
  }: {
    columnName: string;
    columnType: string;
  }) => {
    const isNumeric =
      columnType === "number" ||
      columnType === "integer" ||
      columnType === "float";
    const isAlreadyField = insight.selectedFields?.some((id: UUID) => {
      const f = fields.find((field) => field.id === id);
      return f && (f.columnName ?? f.name) === columnName;
    });
    const aggregations: InsightMetric["aggregation"][] = isNumeric
      ? ["sum", "avg", "min", "max", "count"]
      : ["count", "count_distinct"];

    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <button className="text-muted-foreground hover:bg-muted/50 flex items-center gap-1 px-3 py-2 text-left text-xs font-semibold transition-colors">
            {columnName}
            <ChevronDown className="h-3 w-3 opacity-50" />
          </button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="start" className="w-48">
          <DropdownMenuLabel className="text-xs">
            Add &quot;{columnName}&quot; as
          </DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            onClick={() => handleAddField(columnName)}
            disabled={isAlreadyField}
          >
            <Hash className="mr-2 h-4 w-4" />
            Field (group by)
          </DropdownMenuItem>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger>
              <Calculator className="mr-2 h-4 w-4" />
              Metric
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              {aggregations.map((agg) => (
                <DropdownMenuItem
                  key={agg}
                  onClick={() => handleAddMetric(columnName, agg)}
                >
                  {agg}({columnName})
                </DropdownMenuItem>
              ))}
            </DropdownMenuSubContent>
          </DropdownMenuSub>
        </DropdownMenuContent>
      </DropdownMenu>
    );
  };

  // Render configured state (edit fields, metrics, filters, joins)
  return (
    <div className="flex-1">
      <div className="container mx-auto max-w-6xl space-y-6 px-6 py-6">
        {/* Data Sources Section with ItemList */}
        <section className="border-border bg-card space-y-3 rounded-2xl border p-6 shadow-sm">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-muted-foreground text-xs font-semibold">
                Data sources
              </p>
              <p className="text-foreground text-sm">
                Tables used in this insight
              </p>
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setIsJoinFlowOpen(true)}
            >
              <Plus className="mr-1 h-4 w-4" />
              Add join
            </Button>
          </div>
          <ItemList
            items={dataSourceItems}
            onSelect={() => {}}
            orientation="horizontal"
            gap={12}
            itemWidth={260}
            emptyMessage="No data sources"
            emptyIcon={<Database className="h-8 w-8" />}
          />
        </section>

        {/* Join Preview with Clickable Headers */}
        <Card>
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold">Join preview</h3>
                <p className="text-muted-foreground text-xs">
                  Combined data from {1 + (insight.joins?.length ?? 0)} table
                  {(insight.joins?.length ?? 0) !== 0 ? "s" : ""} â€¢ Click
                  headers to add fields
                </p>
              </div>
              <div className="text-muted-foreground text-xs">
                {joinedPreviewData?.totalCount.toLocaleString()} rows
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {isLoadingJoinedData ? (
              <div className="flex h-32 items-center justify-center">
                <div className="flex flex-col items-center gap-2">
                  <div className="h-5 w-5 animate-spin rounded-full border-2 border-current border-t-transparent" />
                  <span className="text-muted-foreground text-xs">
                    Computing join...
                  </span>
                </div>
              </div>
            ) : joinedPreviewData ? (
              <div className="bg-muted/20 relative overflow-hidden rounded-xl border">
                <div className="overflow-auto" style={{ maxHeight: 200 }}>
                  <table className="w-full border-separate border-spacing-0 text-sm">
                    <thead className="bg-card sticky top-0 z-10">
                      <tr>
                        {joinedPreviewData.columns.map((col) => (
                          <th key={col.name} className="text-left">
                            <ColumnHeaderDropdown
                              columnName={col.name}
                              columnType={col.type ?? "unknown"}
                            />
                          </th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {joinedPreviewData.sampleRows
                        .slice(0, 10)
                        .map((row, idx) => (
                          <tr key={idx} className="border-b last:border-0">
                            {joinedPreviewData.columns.map((col) => (
                              <td
                                key={col.name}
                                className="whitespace-nowrap px-3 py-2 text-xs"
                              >
                                {formatCellValue(
                                  (row as Record<string, unknown>)[col.name],
                                )}
                              </td>
                            ))}
                          </tr>
                        ))}
                    </tbody>
                  </table>
                </div>
              </div>
            ) : (
              <p className="text-muted-foreground text-sm">
                No data available.
              </p>
            )}
          </CardContent>
        </Card>

        {/* Fields (Dimensions) - Removable Item List */}
        <Card>
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold">Fields (Dimensions)</h3>
                <p className="text-muted-foreground text-xs">
                  Columns to group by
                </p>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {selectedFields.length > 0 ? (
              <div className="flex flex-wrap gap-2">
                {selectedFields.map((field) => {
                  const isJoined = (
                    field as LocalField & { _isJoined?: boolean }
                  )._isJoined;
                  return (
                    <Badge
                      key={field.id}
                      variant="secondary"
                      className="flex items-center gap-1.5 px-3 py-1.5 text-sm"
                    >
                      <Hash className="h-3 w-3" />
                      <span>{field.name}</span>
                      <span className="text-muted-foreground text-[10px]">
                        {field.type}
                      </span>
                      <span className="bg-muted rounded px-1.5 py-0.5 text-[10px]">
                        {isJoined ? "joined" : "base"}
                      </span>
                      <button
                        onClick={() => handleRemoveField(field.id)}
                        className="hover:bg-muted ml-0.5 rounded-full p-0.5"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  );
                })}
              </div>
            ) : (
              <p className="text-muted-foreground text-sm">
                No fields selected. Click a column header above to add.
              </p>
            )}
          </CardContent>
        </Card>

        {/* Metrics - Removable Item List */}
        <Card>
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold">Metrics</h3>
                <p className="text-muted-foreground text-xs">
                  Aggregations to compute
                </p>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {visibleMetrics.length > 0 ? (
              <div className="flex flex-wrap gap-2">
                {visibleMetrics.map((metric) => (
                  <Badge
                    key={metric.id}
                    variant="secondary"
                    className="bg-primary/10 text-primary flex items-center gap-1.5 px-3 py-1.5 text-sm"
                  >
                    <Calculator className="h-3 w-3" />
                    <span>{metric.name}</span>
                    <span className="text-primary/60 text-[10px]">
                      {metric.aggregation}
                    </span>
                    <span className="bg-primary/20 rounded px-1.5 py-0.5 text-[10px]">
                      base
                    </span>
                    <button
                      onClick={() => handleRemoveMetric(metric.id)}
                      className="hover:bg-primary/20 ml-0.5 rounded-full p-0.5"
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            ) : (
              <p className="text-muted-foreground text-sm">
                No metrics configured. Click a column header above to add.
              </p>
            )}
          </CardContent>
        </Card>

        {/* Result Preview */}
        {effectiveAggregatedPreview && selectedFields.length > 0 && (
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold">Result preview</h3>
                  <p className="text-muted-foreground text-xs">
                    {effectiveAggregatedPreview.rowCount} groups
                  </p>
                </div>
              </div>
            </CardHeader>
            <CardContent>
              <div className="bg-muted/20 relative overflow-hidden rounded-xl border">
                <div className="overflow-auto" style={{ maxHeight: 200 }}>
                  <table className="w-full border-separate border-spacing-0 text-sm">
                    <thead className="bg-card sticky top-0 z-10">
                      <tr>
                        {/* Use columns from the aggregated result for correct names */}
                        {effectiveAggregatedPreview.dataFrame.columns
                          ?.filter(
                            (col) =>
                              !visibleMetrics.some((m) => m.name === col.name),
                          )
                          .map((col) => (
                            <th
                              key={col.name}
                              className="text-muted-foreground px-3 py-2 text-left text-xs font-semibold"
                            >
                              {col.name}
                            </th>
                          ))}
                        {visibleMetrics.map((metric) => (
                          <th
                            key={metric.id}
                            className="text-primary px-3 py-2 text-left text-xs font-semibold"
                          >
                            {metric.name}
                          </th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {effectiveAggregatedPreview.dataFrame.rows
                        .slice(0, 10)
                        .map((row, idx) => (
                          <tr key={idx} className="border-b last:border-0">
                            {effectiveAggregatedPreview.dataFrame.columns
                              ?.filter(
                                (col) =>
                                  !visibleMetrics.some(
                                    (m) => m.name === col.name,
                                  ),
                              )
                              .map((col) => (
                                <td
                                  key={col.name}
                                  className="whitespace-nowrap px-3 py-2 text-xs"
                                >
                                  {formatCellValue(
                                    (row as Record<string, unknown>)[col.name],
                                  )}
                                </td>
                              ))}
                            {visibleMetrics.map((metric) => (
                              <td
                                key={metric.id}
                                className="text-primary whitespace-nowrap px-3 py-2 text-xs font-medium"
                              >
                                {formatCellValue(
                                  (row as Record<string, unknown>)[metric.name],
                                )}
                              </td>
                            ))}
                          </tr>
                        ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </CardContent>
          </Card>
        )}
      </div>

      {/* Sticky Footer */}
      <div className="bg-card/90 sticky bottom-0 border-t px-6 py-4 backdrop-blur-sm">
        <div className="container mx-auto max-w-6xl">
          <div className="flex justify-end">
            <Button disabled={selectedFields.length === 0}>
              Create Visualization
            </Button>
          </div>
        </div>
      </div>

      <JoinFlowModal
        insight={insight as any}
        dataTable={dataTable as any}
        isOpen={isJoinFlowOpen}
        onOpenChange={setIsJoinFlowOpen}
      />
    </div>
  );
}
