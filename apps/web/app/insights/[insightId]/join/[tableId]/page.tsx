"use client";

/* eslint-disable sonarjs/cognitive-complexity */

import { use, useState, useMemo, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import type { Field, DataFrameRow } from "@dashframe/core";
import { shortenAutoGeneratedName } from "@dashframe/engine-browser";
import {
  Button,
  Label,
  Select,
  SelectTrigger,
  SelectValue,
  SelectContent,
  SelectItem,
  Alert,
  AlertDescription,
  Surface,
  VirtualTable,
  type VirtualTableColumnConfig,
  type VirtualTableColumn,
  ArrowLeft,
  Merge,
  Loader2,
  AlertCircle,
} from "@dashframe/ui";
import {
  useInsights,
  useInsightMutations,
  useDataTables,
  getDataFrame,
} from "@dashframe/core-dexie";
import { useDataFramePagination } from "@/hooks/useDataFramePagination";
import { useDuckDB } from "@/components/providers/DuckDBProvider";
import type { DataTable, InsightJoinConfig } from "@dashframe/core";

interface PageProps {
  params: Promise<{ insightId: string; tableId: string }>;
}

/** Local type for join preview result (static data for VirtualTable) */
interface JoinPreviewData {
  columns: VirtualTableColumn[];
  rows: DataFrameRow[];
}

const PREVIEW_ROW_LIMIT = 50;

/**
 * Join Configuration Page
 *
 * Provides a full-page experience for configuring joins between two tables:
 * - Side-by-side table previews (responsive: stacked on narrow screens)
 * - Column selection for join keys
 * - Join type selection
 * - Live preview of join result
 */
export default function JoinConfigurePage({ params }: PageProps) {
  const { insightId, tableId: joinTableId } = use(params);
  const router = useRouter();

  // Dexie hooks for data access
  const { data: allInsights, isLoading: isInsightsLoading } = useInsights();
  const { data: allDataTables, isLoading: isTablesLoading } = useDataTables();
  const { update: updateInsight } = useInsightMutations();

  const isLoading = isInsightsLoading || isTablesLoading;

  // Find the current insight
  const insight = useMemo(
    () => allInsights?.find((i) => i.id === insightId),
    [allInsights, insightId],
  );

  // Join configuration state
  const [leftFieldId, setLeftFieldId] = useState<string | null>(null);
  const [rightFieldId, setRightFieldId] = useState<string | null>(null);
  const [joinType, setJoinType] = useState<
    "inner" | "left" | "right" | "outer"
  >("inner");
  const intersectionFill = useMemo(() => {
    if (joinType === "inner") {
      return "rgba(251, 191, 36, 0.5)";
    }

    if (joinType === "left" || joinType === "right") {
      return "rgba(251, 191, 36, 0.3)";
    }

    return "rgba(251, 191, 36, 0.2)";
  }, [joinType]);
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [previewResult, setPreviewResult] = useState<JoinPreviewData | null>(
    null,
  );
  const [isComputingPreview, setIsComputingPreview] = useState(false);

  // Resolve base table (from insight's baseTableId)
  const baseTable = useMemo(() => {
    if (!insight || !allDataTables) return null;
    return allDataTables.find((t) => t.id === insight.baseTableId) ?? null;
  }, [insight, allDataTables]);

  // Resolve join table (from tableId param)
  const joinTable = useMemo(() => {
    if (!allDataTables) return null;
    return allDataTables.find((t) => t.id === joinTableId) ?? null;
  }, [allDataTables, joinTableId]);

  // DuckDB connection for join preview
  const { connection, isInitialized: isDuckDBReady } = useDuckDB();

  // Pagination hooks for async VirtualTable (full dataset browsing)
  const {
    fetchData: fetchBaseData,
    totalCount: baseTotalCount,
    isReady: isBaseReady,
  } = useDataFramePagination(baseTable?.dataFrameId);

  const {
    fetchData: fetchJoinData,
    totalCount: joinTotalCount,
    isReady: isJoinReady,
  } = useDataFramePagination(joinTable?.dataFrameId);

  // Filter out internal fields (those starting with _)
  const baseFields = useMemo(
    () => baseTable?.fields?.filter((f) => !f.name.startsWith("_")) ?? [],
    [baseTable],
  );

  const joinFields = useMemo(
    () => joinTable?.fields?.filter((f) => !f.name.startsWith("_")) ?? [],
    [joinTable],
  );

  // Column configs for highlighting selected columns in source tables
  const baseColumnConfigs = useMemo((): VirtualTableColumnConfig[] => {
    const leftField = baseFields.find((f) => f.id === leftFieldId);
    if (!leftField) return [];
    return [{ id: leftField.columnName ?? leftField.name, highlight: true }];
  }, [baseFields, leftFieldId]);

  const joinColumnConfigs = useMemo((): VirtualTableColumnConfig[] => {
    const rightField = joinFields.find((f) => f.id === rightFieldId);
    if (!rightField) return [];
    return [{ id: rightField.columnName ?? rightField.name, highlight: true }];
  }, [joinFields, rightFieldId]);

  // Column configs for the preview result - highlight base vs join columns
  const previewColumnConfigs = useMemo((): VirtualTableColumnConfig[] => {
    if (!previewResult?.columns || !baseTable || !joinTable) return [];

    // Get column names from each source table
    const baseColumnNames = new Set(
      baseFields.map((f) => f.columnName ?? f.name),
    );
    const joinColumnNames = new Set(
      joinFields.map((f) => f.columnName ?? f.name),
    );

    // Get table display names for prefix detection (must match SQL generation)
    const baseDisplayName = shortenAutoGeneratedName(baseTable.name);
    const joinDisplayName = shortenAutoGeneratedName(joinTable.name);

    return previewResult.columns
      .filter((col) => !col.name.startsWith("_"))
      .map((col) => {
        // Check if this column came from base or join table
        // Handle table name prefix format: "tableName.columnName"
        const hasBasePrefix = col.name.startsWith(`${baseDisplayName}.`);
        const hasJoinPrefix = col.name.startsWith(`${joinDisplayName}.`);

        // Determine highlight variant
        // If column has a prefix, it's definitively from ONE table only
        // (the prefix was added to disambiguate duplicate column names)
        let highlight: "base" | "join" | "both" | undefined;
        if (hasBasePrefix) {
          highlight = "base";
        } else if (hasJoinPrefix) {
          highlight = "join";
        } else {
          // No prefix - check which table(s) this column belongs to
          const isFromBase = baseColumnNames.has(col.name);
          const isFromJoin = joinColumnNames.has(col.name);

          if (isFromBase && isFromJoin) {
            // Column name exists in both original tables, but check if the other
            // table's version was prefixed (meaning this unprefixed one is from just one table)
            const hasBasePrefixedVersion = previewResult.columns.some(
              (c) => c.name === `${baseDisplayName}.${col.name}`,
            );
            const hasJoinPrefixedVersion = previewResult.columns.some(
              (c) => c.name === `${joinDisplayName}.${col.name}`,
            );

            if (hasJoinPrefixedVersion) {
              // Join table's version was prefixed, so unprefixed is from base only
              highlight = "base";
            } else if (hasBasePrefixedVersion) {
              // Base table's version was prefixed, so unprefixed is from join only
              highlight = "join";
            } else {
              // Neither was prefixed - genuinely in both (rare, e.g., join key)
              highlight = "both";
            }
          } else if (isFromBase) {
            highlight = "base";
          } else if (isFromJoin) {
            highlight = "join";
          }
        }

        return {
          id: col.name,
          highlight,
        };
      })
      .filter(
        (config) => config.highlight !== undefined,
      ) as VirtualTableColumnConfig[];
  }, [previewResult, baseTable, joinTable, baseFields, joinFields]);

  // Join analysis results for Venn diagram visualization
  const [joinAnalysis, setJoinAnalysis] = useState<{
    baseUniqueCount: number;
    joinUniqueCount: number;
    matchingCount: number; // values that exist in both
    estimatedResultRows: number; // approximate rows after join
  } | null>(null);

  // Find columns with matching names (for suggestions) with analysis
  const [columnSuggestions, setColumnSuggestions] = useState<
    Array<{
      leftField: (typeof baseFields)[0];
      rightField: (typeof joinFields)[0];
      columnName: string;
      matchingValues: number; // how many values match between tables
      baseUniqueValues: number;
    }>
  >([]);

  // Analyze matching columns for suggestions
  useEffect(() => {
    if (!connection || !isDuckDBReady) return;
    if (!baseTable?.dataFrameId || !joinTable?.dataFrameId) return;
    // Wait for pagination hooks to be ready (they load the data into DuckDB)
    if (!isBaseReady || !isJoinReady) return;

    const baseColMap = new Map<
      string,
      { field: (typeof baseFields)[0]; name: string }
    >();
    for (const field of baseFields) {
      const colName = field.columnName ?? field.name;
      baseColMap.set(colName.toLowerCase(), { field, name: colName });
    }

    const pairs: Array<{
      leftField: (typeof baseFields)[0];
      rightField: (typeof joinFields)[0];
      columnName: string;
    }> = [];
    for (const joinField of joinFields) {
      const joinColName = joinField.columnName ?? joinField.name;
      const baseMatch = baseColMap.get(joinColName.toLowerCase());
      if (baseMatch) {
        pairs.push({
          leftField: baseMatch.field,
          rightField: joinField,
          columnName: joinColName,
        });
      }
    }

    if (pairs.length === 0) {
      setColumnSuggestions([]);
      return;
    }

    const baseTableName = `df_${baseTable.dataFrameId!.replace(/-/g, "_")}`;
    const joinTableName = `df_${joinTable.dataFrameId!.replace(/-/g, "_")}`;

    const analyze = async () => {
      try {
        // Tables are already loaded by the pagination hooks

        const results: typeof columnSuggestions = [];

        for (const pair of pairs) {
          const leftColName = pair.leftField.columnName ?? pair.leftField.name;
          const rightColName =
            pair.rightField.columnName ?? pair.rightField.name;

          const sql = `
            WITH base_vals AS (SELECT DISTINCT "${leftColName}" as val FROM ${baseTableName}),
            join_vals AS (SELECT DISTINCT "${rightColName}" as val FROM ${joinTableName})
            SELECT
              (SELECT COUNT(*) FROM base_vals) as base_unique,
              (SELECT COUNT(*) FROM base_vals b WHERE EXISTS (SELECT 1 FROM join_vals j WHERE j.val = b.val)) as matching
          `;

          const result = await connection.query(sql);
          const row = result.toArray()[0] as {
            base_unique: number;
            matching: number;
          };

          results.push({
            ...pair,
            matchingValues: Number(row?.matching ?? 0),
            baseUniqueValues: Number(row?.base_unique ?? 0),
          });
        }

        // Sort by matching values (higher = better)
        results.sort((a, b) => b.matchingValues - a.matchingValues);
        setColumnSuggestions(results);
      } catch (err) {
        console.error("Failed to analyze column suggestions:", err);
        // Fallback without analysis
        setColumnSuggestions(
          pairs.map((p) => ({ ...p, matchingValues: 0, baseUniqueValues: 0 })),
        );
      }
    };

    analyze();
  }, [
    connection,
    isDuckDBReady,
    baseTable,
    joinTable,
    baseFields,
    joinFields,
    isBaseReady,
    isJoinReady,
  ]);

  // Apply a suggestion
  const applySuggestion = useCallback((pair: (typeof columnSuggestions)[0]) => {
    setLeftFieldId(pair.leftField.id);
    setRightFieldId(pair.rightField.id);
  }, []);

  // Analyze selected columns for Venn diagram
  useEffect(() => {
    if (!leftFieldId || !rightFieldId) {
      setJoinAnalysis(null);
      return;
    }
    if (!connection || !isDuckDBReady) return;
    if (!baseTable?.dataFrameId || !joinTable?.dataFrameId) return;

    const leftField = baseFields.find((f) => f.id === leftFieldId);
    const rightField = joinFields.find((f) => f.id === rightFieldId);
    if (!leftField || !rightField) return;

    const leftColumnName = leftField.columnName ?? leftField.name;
    const rightColumnName = rightField.columnName ?? rightField.name;

    const analyze = async () => {
      try {
        // Get DataFrames from Dexie (async)
        const baseDataFrame = await getDataFrame(baseTable.dataFrameId!);
        const joinDataFrame = await getDataFrame(joinTable.dataFrameId!);
        if (!baseDataFrame || !joinDataFrame) return;

        await baseDataFrame.load(connection);
        await joinDataFrame.load(connection);

        const baseTableName = `df_${baseTable.dataFrameId!.replace(/-/g, "_")}`;
        const joinTableName = `df_${joinTable.dataFrameId!.replace(/-/g, "_")}`;

        // Get Venn diagram stats
        const vennSQL = `
          WITH base_values AS (
            SELECT DISTINCT "${leftColumnName}" as val FROM ${baseTableName}
          ),
          join_values AS (
            SELECT DISTINCT "${rightColumnName}" as val FROM ${joinTableName}
          ),
          matching AS (
            SELECT b.val FROM base_values b
            INNER JOIN join_values j ON b.val = j.val
          )
          SELECT
            (SELECT COUNT(*) FROM base_values) as base_unique,
            (SELECT COUNT(*) FROM join_values) as join_unique,
            (SELECT COUNT(*) FROM matching) as matching_count
        `;

        const vennResult = await connection.query(vennSQL);
        const vennRow = vennResult.toArray()[0] as {
          base_unique: number;
          join_unique: number;
          matching_count: number;
        };

        // Estimate result rows (for inner join)
        const countSQL = `
          SELECT COUNT(*) as cnt
          FROM ${baseTableName} b
          INNER JOIN ${joinTableName} j ON b."${leftColumnName}" = j."${rightColumnName}"
        `;
        const countResult = await connection.query(countSQL);
        const countRow = countResult.toArray()[0] as { cnt: number };

        setJoinAnalysis({
          baseUniqueCount: Number(vennRow?.base_unique ?? 0),
          joinUniqueCount: Number(vennRow?.join_unique ?? 0),
          matchingCount: Number(vennRow?.matching_count ?? 0),
          estimatedResultRows: Number(countRow?.cnt ?? 0),
        });
      } catch (err) {
        console.error("Failed to analyze join:", err);
        setJoinAnalysis(null);
      }
    };

    analyze();
  }, [
    leftFieldId,
    rightFieldId,
    connection,
    isDuckDBReady,
    baseTable,
    joinTable,
    baseFields,
    joinFields,
    getDataFrame,
  ]);

  // Compute join preview using DuckDB (handles full dataset efficiently)
  useEffect(() => {
    if (!leftFieldId || !rightFieldId) {
      setPreviewResult(null);
      return;
    }

    if (!connection || !isDuckDBReady) {
      return;
    }

    if (!baseTable?.dataFrameId || !joinTable?.dataFrameId) {
      return;
    }

    const leftField = baseFields.find((f) => f.id === leftFieldId);
    const rightField = joinFields.find((f) => f.id === rightFieldId);

    if (!leftField || !rightField) {
      setPreviewResult(null);
      return;
    }

    const leftColumnName = leftField.columnName ?? leftField.name;
    const rightColumnName = rightField.columnName ?? rightField.name;

    setIsComputingPreview(true);
    setError(null);

    const computeJoin = async () => {
      try {
        // Get DataFrames from Dexie (async)
        const baseDataFrame = await getDataFrame(baseTable.dataFrameId!);
        const joinDataFrame = await getDataFrame(joinTable.dataFrameId!);

        if (!baseDataFrame || !joinDataFrame) {
          setError("Could not load DataFrames");
          return;
        }

        // Load both tables into DuckDB (side effect ensures tables exist)
        await baseDataFrame.load(connection);
        await joinDataFrame.load(connection);

        const baseTableName = `df_${baseTable.dataFrameId!.replace(/-/g, "_")}`;
        const joinTableName = `df_${joinTable.dataFrameId!.replace(/-/g, "_")}`;

        // Build the JOIN SQL
        const joinTypeSQL = joinType.toUpperCase();

        // Get column lists, handling duplicates with table name prefixes
        const baseColNames = baseFields.map((f) => f.columnName ?? f.name);
        const joinColNames = joinFields.map((f) => f.columnName ?? f.name);

        // Get display names for table prefixes (cleaned of UUIDs)
        const baseDisplayName = shortenAutoGeneratedName(baseTable.name);
        const joinDisplayName = shortenAutoGeneratedName(joinTable.name);

        // Build SELECT clause with table name prefixes for duplicate columns
        const selectParts: string[] = [];

        for (const col of baseColNames) {
          if (col.startsWith("_")) continue; // Skip internal columns
          const isDuplicate =
            joinColNames.includes(col) && col !== leftColumnName;
          if (isDuplicate) {
            // Use table name prefix: "accounts.acctid" instead of "acctid_base"
            selectParts.push(`base."${col}" AS "${baseDisplayName}.${col}"`);
          } else {
            selectParts.push(`base."${col}"`);
          }
        }

        // Build lowercase set of base column names for case-insensitive duplicate detection
        const baseColNamesLower = new Set(
          baseColNames.map((c) => c.toLowerCase()),
        );

        for (const col of joinColNames) {
          if (col.startsWith("_")) continue; // Skip internal columns
          // For INNER joins, skip the join key column - it's redundant with base table's
          // join key (they have the same values for all matched rows).
          // For LEFT/RIGHT/OUTER joins, keep both since NULLs may differ.
          if (joinType === "inner" && col === rightColumnName) continue;
          // Check for duplicate using case-insensitive comparison
          // DuckDB treats column names case-insensitively, so "acctId" and "acctid" conflict
          const isDuplicate = baseColNamesLower.has(col.toLowerCase());
          if (isDuplicate) {
            // Use table name prefix: "opportunities.acctid" instead of "acctid_1"
            selectParts.push(`j."${col}" AS "${joinDisplayName}.${col}"`);
          } else {
            selectParts.push(`j."${col}"`);
          }
        }

        const joinSQL = `
          SELECT ${selectParts.join(", ")}
          FROM ${baseTableName} AS base
          ${joinTypeSQL} JOIN ${joinTableName} AS j
          ON base."${leftColumnName}" = j."${rightColumnName}"
          LIMIT ${PREVIEW_ROW_LIMIT}
        `;

        console.log("[JoinPreview] Executing DuckDB join:", joinSQL);

        const result = await connection.query(joinSQL);
        const rows = result.toArray() as DataFrameRow[];

        // Get total count for the join
        const countSQL = `
          SELECT COUNT(*) as count
          FROM ${baseTableName} AS base
          ${joinTypeSQL} JOIN ${joinTableName} AS j
          ON base."${leftColumnName}" = j."${rightColumnName}"
        `;
        const countResult = await connection.query(countSQL);
        const totalJoinCount = Number(countResult.toArray()[0]?.count ?? 0);

        // Build columns from the result
        const columns: VirtualTableColumn[] =
          rows.length > 0
            ? Object.keys(rows[0])
                .filter((key) => !key.startsWith("_"))
                .map((name) => ({ name }))
            : [];

        console.log("[JoinPreview] DuckDB result:", {
          previewRows: rows.length,
          totalJoinCount,
          columns: columns.length,
        });

        setPreviewResult({ columns, rows });
        // Store total count for display
        setPreviewTotalCount(totalJoinCount);
      } catch (err) {
        console.error("DuckDB join preview failed:", err);
        setPreviewResult(null);
        const errorMessage =
          err instanceof Error ? err.message : "Unknown error";
        setError(`Join preview failed: ${errorMessage}`);
      } finally {
        setIsComputingPreview(false);
      }
    };

    computeJoin();
  }, [
    leftFieldId,
    rightFieldId,
    joinType,
    connection,
    isDuckDBReady,
    baseTable,
    joinTable,
    baseFields,
    joinFields,
    getDataFrame,
  ]);

  // Track total join count for display
  const [previewTotalCount, setPreviewTotalCount] = useState<number>(0);

  // Execute full join and add to existing insight
  // Note: We only store the join configuration here. The actual join is computed
  // on-demand when displaying the preview in InsightConfigureTab.
  const handleExecuteJoin = useCallback(async () => {
    if (!leftFieldId || !rightFieldId) {
      setError("Select both join columns.");
      return;
    }

    if (!baseTable || !joinTable || !insight) {
      setError("Unable to load table data.");
      return;
    }

    const leftField = baseFields.find((f) => f.id === leftFieldId);
    const rightField = joinFields.find((f) => f.id === rightFieldId);

    if (!leftField || !rightField) {
      setError("Selected columns are no longer available.");
      return;
    }

    setError(null);
    setIsSubmitting(true);

    // Validate the join works by testing it (using preview result)
    // The preview is already computed, so we just check if it succeeded
    if (!previewResult || previewResult.rows.length === 0) {
      // Still allow the join even with 0 rows - user may want to keep the config
      // Just warn them in the UI (handled by the existing Alert component)
    }

    // Create join config using the Core schema
    // Uses column names (strings) as join keys, not field UUIDs
    const joinConfig: InsightJoinConfig = {
      type: joinType === "outer" ? "full" : joinType, // "outer" → "full" for Core type
      rightTableId: joinTable!.id,
      leftKey: leftField.columnName ?? leftField.name,
      rightKey: rightField.columnName ?? rightField.name,
    };

    // Add join to existing insight (append to existing joins if any)
    const existingJoins = insight.joins ?? [];
    await updateInsight(insightId, {
      joins: [...existingJoins, joinConfig],
    });

    // Note: We intentionally do NOT store a pre-computed joined DataFrame here.
    // The join preview in InsightConfigureTab computes the join on-demand,
    // which ensures we always show raw joined data (not aggregated data).

    setIsSubmitting(false);
    // Navigate back to the same insight
    router.push(`/insights/${insightId}`);
  }, [
    leftFieldId,
    rightFieldId,
    joinType,
    baseTable,
    joinTable,
    baseFields,
    joinFields,
    insight,
    insightId,
    updateInsight,
    previewResult,
    router,
  ]);

  // Loading state - wait for all stores to hydrate before rendering
  if (isLoading) {
    return (
      <div className="bg-background flex h-screen items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="text-muted-foreground h-8 w-8 animate-spin" />
          <p className="text-muted-foreground text-sm">
            Loading join configuration...
          </p>
        </div>
      </div>
    );
  }

  // Error states
  if (!insight) {
    return (
      <div className="bg-background flex h-screen items-center justify-center">
        <Surface elevation="raised" className="p-8 text-center">
          <AlertCircle className="text-muted-foreground mx-auto mb-4 h-10 w-10" />
          <h2 className="text-xl font-semibold">Insight not found</h2>
          <p className="text-muted-foreground mt-2 text-sm">
            The insight you&apos;re looking for doesn&apos;t exist.
          </p>
          <Button onClick={() => router.push("/insights")} className="mt-4">
            Go to Insights
          </Button>
        </Surface>
      </div>
    );
  }

  if (!baseTable) {
    return (
      <div className="bg-background flex h-screen items-center justify-center">
        <Surface elevation="raised" className="p-8 text-center">
          <AlertCircle className="text-muted-foreground mx-auto mb-4 h-10 w-10" />
          <h2 className="text-xl font-semibold">Base table not found</h2>
          <p className="text-muted-foreground mt-2 text-sm">
            The data table for this insight no longer exists.
          </p>
          <Button onClick={() => router.push("/insights")} className="mt-4">
            Go to Insights
          </Button>
        </Surface>
      </div>
    );
  }

  if (!joinTable) {
    return (
      <div className="bg-background flex h-screen items-center justify-center">
        <Surface elevation="raised" className="p-8 text-center">
          <AlertCircle className="text-muted-foreground mx-auto mb-4 h-10 w-10" />
          <h2 className="text-xl font-semibold">Join table not found</h2>
          <p className="text-muted-foreground mt-2 text-sm">
            The table you&apos;re trying to join with doesn&apos;t exist.
          </p>
          <Button
            onClick={() => router.push(`/insights/${insightId}`)}
            className="mt-4"
          >
            Back to Insight
          </Button>
        </Surface>
      </div>
    );
  }

  const canJoin = leftFieldId && rightFieldId;

  return (
    <div className="bg-background flex h-screen flex-col">
      {/* Header */}
      <header className="bg-card/90 sticky top-0 z-10 border-b backdrop-blur-sm">
        <div className="container mx-auto px-6 py-4">
          <div className="flex flex-wrap items-center justify-between gap-4">
            <div className="flex items-center gap-4">
              <Button
                variant="ghost"
                size="sm"
                onClick={() => router.push(`/insights/${insightId}`)}
              >
                <ArrowLeft className="mr-2 h-4 w-4" />
                Cancel
              </Button>
              <div>
                <h1 className="text-xl font-semibold">
                  Join: {baseTable.name} + {joinTable.name}
                </h1>
                <p className="text-muted-foreground text-sm">
                  Configure how to combine these datasets
                </p>
              </div>
            </div>
            <Button
              onClick={handleExecuteJoin}
              disabled={!canJoin || isSubmitting}
            >
              {isSubmitting ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <Merge className="mr-2 h-4 w-4" />
              )}
              {isSubmitting ? "Joining..." : "Join Tables"}
            </Button>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="flex-1 overflow-auto">
        <div className="container mx-auto space-y-6 px-6 py-6">
          {/* Dual Table Previews */}
          <div className="grid gap-6 md:grid-cols-2">
            {/* Base Table Preview */}
            <TablePreviewSection
              title="Base Table"
              table={baseTable}
              totalCount={baseTotalCount}
              isReady={isBaseReady}
              onFetchData={fetchBaseData}
              fields={baseTable.fields}
              columnConfigs={baseColumnConfigs}
              onHeaderClick={(colName) => {
                const field = baseFields.find(
                  (f) => (f.columnName ?? f.name) === colName,
                );
                if (field) setLeftFieldId(field.id);
              }}
            />

            {/* Join Table Preview */}
            <TablePreviewSection
              title="Join Table"
              table={joinTable}
              totalCount={joinTotalCount}
              isReady={isJoinReady}
              onFetchData={fetchJoinData}
              fields={joinTable.fields}
              columnConfigs={joinColumnConfigs}
              onHeaderClick={(colName) => {
                const field = joinFields.find(
                  (f) => (f.columnName ?? f.name) === colName,
                );
                if (field) setRightFieldId(field.id);
              }}
            />
          </div>

          {/* Join Configuration */}
          <Surface elevation="raised" className="rounded-2xl p-6">
            <h2 className="mb-4 text-lg font-semibold">Join Configuration</h2>

            {/* Matching column suggestions */}
            {columnSuggestions.length > 0 && (
              <div className="bg-muted/50 border-border/60 mb-6 rounded-xl border p-4">
                <div className="mb-3 flex items-center gap-2">
                  <span className="text-sm font-medium">
                    Matching columns found
                  </span>
                  <span className="text-muted-foreground text-xs">
                    – click to select
                  </span>
                </div>
                <div className="flex flex-wrap gap-2">
                  {columnSuggestions.map((pair) => (
                    <button
                      key={pair.columnName}
                      type="button"
                      onClick={() => applySuggestion(pair)}
                      className="border-border bg-card hover:bg-primary/10 hover:border-primary/50 group flex cursor-pointer items-center gap-2 rounded-lg border px-3 py-2 text-sm transition-colors"
                    >
                      <span className="text-foreground group-hover:text-primary font-medium">
                        {pair.leftField.columnName ?? pair.leftField.name}
                      </span>
                      <span className="text-muted-foreground">↔</span>
                      <span className="text-foreground group-hover:text-primary font-medium">
                        {pair.rightField.columnName ?? pair.rightField.name}
                      </span>
                      {pair.matchingValues > 0 && (
                        <span className="text-muted-foreground ml-1 text-xs">
                          ({pair.matchingValues.toLocaleString()} matching)
                        </span>
                      )}
                    </button>
                  ))}
                </div>
              </div>
            )}

            <div className="grid gap-6 lg:grid-cols-2">
              {/* Column Selection */}
              <div className="space-y-4">
                <div className="grid gap-4 sm:grid-cols-2">
                  <div className="space-y-2">
                    <Label htmlFor="left-column">Base table column</Label>
                    <Select
                      value={leftFieldId ?? ""}
                      onValueChange={(value) => setLeftFieldId(value || null)}
                    >
                      <SelectTrigger id="left-column">
                        <SelectValue placeholder="Select column..." />
                      </SelectTrigger>
                      <SelectContent>
                        {baseFields.map((field) => (
                          <SelectItem key={field.id} value={field.id}>
                            {field.name}
                            <span className="text-muted-foreground ml-2 text-xs">
                              ({field.type})
                            </span>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="right-column">Join table column</Label>
                    <Select
                      value={rightFieldId ?? ""}
                      onValueChange={(value) => setRightFieldId(value || null)}
                    >
                      <SelectTrigger id="right-column">
                        <SelectValue placeholder="Select column..." />
                      </SelectTrigger>
                      <SelectContent>
                        {joinFields.map((field) => (
                          <SelectItem key={field.id} value={field.id}>
                            {field.name}
                            <span className="text-muted-foreground ml-2 text-xs">
                              ({field.type})
                            </span>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="join-type">Join type</Label>
                  <Select
                    value={joinType}
                    onValueChange={(value) =>
                      setJoinType(value as "inner" | "left" | "right" | "outer")
                    }
                  >
                    <SelectTrigger id="join-type">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="inner">
                        Inner
                        <span className="text-muted-foreground ml-2 text-xs">
                          (only matching rows)
                        </span>
                      </SelectItem>
                      <SelectItem value="left">
                        Left
                        <span className="text-muted-foreground ml-2 text-xs">
                          (all base + matching)
                        </span>
                      </SelectItem>
                      <SelectItem value="right">
                        Right
                        <span className="text-muted-foreground ml-2 text-xs">
                          (matching + all join)
                        </span>
                      </SelectItem>
                      <SelectItem value="outer">
                        Outer
                        <span className="text-muted-foreground ml-2 text-xs">
                          (all rows from both)
                        </span>
                      </SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>

              {/* Venn Diagram Visualization */}
              {joinAnalysis && (
                <div className="flex flex-col items-center justify-center">
                  {/* SVG Venn Diagram */}
                  <svg
                    viewBox="0 0 200 120"
                    className="h-auto w-full max-w-[280px]"
                  >
                    {/* Base table circle (left) */}
                    <circle
                      cx="70"
                      cy="60"
                      r="45"
                      fill="rgba(59, 130, 246, 0.2)"
                      stroke="rgb(59, 130, 246)"
                      strokeWidth="2"
                    />
                    {/* Join table circle (right) */}
                    <circle
                      cx="130"
                      cy="60"
                      r="45"
                      fill="rgba(16, 185, 129, 0.2)"
                      stroke="rgb(16, 185, 129)"
                      strokeWidth="2"
                    />
                    {/* Intersection highlight based on join type */}
                    <clipPath id="leftClip">
                      <circle cx="70" cy="60" r="45" />
                    </clipPath>
                    <clipPath id="rightClip">
                      <circle cx="130" cy="60" r="45" />
                    </clipPath>
                    {/* Intersection area */}
                    <circle
                      cx="130"
                      cy="60"
                      r="45"
                      clipPath="url(#leftClip)"
                      fill={intersectionFill}
                      stroke="rgb(251, 191, 36)"
                      strokeWidth={joinType === "inner" ? "2" : "1"}
                    />
                    {/* Labels */}
                    <text
                      x="45"
                      y="60"
                      textAnchor="middle"
                      className="fill-blue-600 text-[10px] font-medium"
                    >
                      {(
                        joinAnalysis.baseUniqueCount -
                        joinAnalysis.matchingCount
                      ).toLocaleString()}
                    </text>
                    <text
                      x="100"
                      y="55"
                      textAnchor="middle"
                      className="fill-amber-600 text-[11px] font-bold"
                    >
                      {joinAnalysis.matchingCount.toLocaleString()}
                    </text>
                    <text
                      x="100"
                      y="68"
                      textAnchor="middle"
                      className="fill-amber-600 text-[8px]"
                    >
                      matching
                    </text>
                    <text
                      x="155"
                      y="60"
                      textAnchor="middle"
                      className="fill-emerald-600 text-[10px] font-medium"
                    >
                      {(
                        joinAnalysis.joinUniqueCount -
                        joinAnalysis.matchingCount
                      ).toLocaleString()}
                    </text>
                    {/* Circle labels */}
                    <text
                      x="45"
                      y="110"
                      textAnchor="middle"
                      className="fill-muted-foreground text-[9px]"
                    >
                      Base
                    </text>
                    <text
                      x="155"
                      y="110"
                      textAnchor="middle"
                      className="fill-muted-foreground text-[9px]"
                    >
                      Join
                    </text>
                  </svg>

                  {/* Result summary */}
                  <div className="mt-3 text-center">
                    <p className="text-sm font-medium">
                      {joinType === "inner" && (
                        <>
                          Result:{" "}
                          <span className="text-amber-600">
                            {joinAnalysis.estimatedResultRows.toLocaleString()}
                          </span>{" "}
                          rows
                        </>
                      )}
                      {joinType === "left" && (
                        <>Result: all base rows + matched join data</>
                      )}
                      {joinType === "right" && (
                        <>Result: matched base data + all join rows</>
                      )}
                      {joinType === "outer" && (
                        <>Result: all rows from both tables</>
                      )}
                    </p>
                    <p className="text-muted-foreground mt-1 text-xs">
                      {joinAnalysis.matchingCount.toLocaleString()} of{" "}
                      {joinAnalysis.baseUniqueCount.toLocaleString()} base
                      values have matches
                    </p>
                  </div>
                </div>
              )}
            </div>
          </Surface>

          {/* Error Display */}
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {/* Preview Result */}
          {canJoin && (
            <Surface elevation="raised" className="rounded-2xl p-6">
              <div className="mb-4 flex items-center justify-between">
                <h2 className="text-lg font-semibold">Preview Result</h2>
                {isComputingPreview && (
                  <div className="text-muted-foreground flex items-center gap-2 text-sm">
                    <Loader2 className="h-4 w-4 animate-spin" />
                    Computing preview...
                  </div>
                )}
                {!isComputingPreview && previewResult && (
                  <p className="text-muted-foreground text-sm">
                    {previewTotalCount.toLocaleString()} total rows
                    {previewTotalCount > PREVIEW_ROW_LIMIT &&
                      ` (showing first ${PREVIEW_ROW_LIMIT})`}
                    {" · "}
                    {previewResult.columns?.length ?? 0} columns
                  </p>
                )}
              </div>

              {/* Preview result or placeholder */}
              {!isComputingPreview && previewResult && (
                <>
                  {/* Legend for column colors */}
                  <div className="mb-3 flex flex-wrap items-center gap-4 text-xs">
                    <div className="flex items-center gap-1.5">
                      <div className="h-3 w-3 rounded bg-blue-600" />
                      <span className="text-muted-foreground">
                        From {baseTable.name ?? "base table"}
                      </span>
                    </div>
                    <div className="flex items-center gap-1.5">
                      <div className="h-3 w-3 rounded bg-emerald-600" />
                      <span className="text-muted-foreground">
                        From {joinTable.name ?? "join table"}
                      </span>
                    </div>
                    <div className="flex items-center gap-1.5">
                      <div className="h-3 w-3 rounded bg-amber-500" />
                      <span className="text-muted-foreground">
                        In both tables
                      </span>
                    </div>
                  </div>
                  <div
                    className="border-border/60 overflow-hidden rounded-xl border"
                    style={{ maxHeight: 300 }}
                  >
                    <VirtualTable
                      rows={previewResult.rows}
                      columns={previewResult.columns}
                      columnConfigs={previewColumnConfigs}
                      height={300}
                      compact
                    />
                  </div>
                </>
              )}
              {!isComputingPreview && !previewResult && (
                <div className="text-muted-foreground flex h-40 items-center justify-center">
                  {error
                    ? "Unable to generate preview"
                    : "Select join columns to see preview"}
                </div>
              )}

              {!isComputingPreview &&
                previewResult &&
                previewResult.rows.length === 0 && (
                  <Alert className="mt-4">
                    <AlertDescription>
                      This join produces 0 rows. Consider using a different join
                      type or checking that the columns have matching values.
                    </AlertDescription>
                  </Alert>
                )}
            </Surface>
          )}
        </div>
      </main>
    </div>
  );
}

// ============================================================================
// Table Preview Section Component
// ============================================================================

interface TablePreviewSectionProps {
  title: string;
  table: DataTable;
  totalCount: number;
  isReady: boolean;
  onFetchData: (
    params: import("@dashframe/ui").FetchDataParams,
  ) => Promise<import("@dashframe/ui").FetchDataResult>;
  fields: Field[];
  columnConfigs?: VirtualTableColumnConfig[];
  onHeaderClick?: (columnName: string) => void;
}

function TablePreviewSection({
  title,
  table,
  totalCount,
  isReady,
  onFetchData,
  fields,
  columnConfigs,
  onHeaderClick,
}: TablePreviewSectionProps) {
  const colCount = fields.filter((f) => !f.name.startsWith("_")).length;

  return (
    <Surface elevation="raised" className="overflow-hidden rounded-2xl">
      <div className="border-border/60 border-b px-4 py-3">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-muted-foreground text-xs uppercase tracking-wide">
              {title}
            </p>
            <p className="font-semibold">{table.name}</p>
          </div>
          <p className="text-muted-foreground text-xs">
            {totalCount.toLocaleString()} rows · {colCount} columns
          </p>
        </div>
        <p className="text-muted-foreground mt-1 text-xs">
          Click a column header to select it for joining
        </p>
      </div>
      <div style={{ height: 260 }} className="overflow-hidden">
        {!isReady ? (
          <div className="text-muted-foreground flex h-40 items-center justify-center">
            <div className="flex flex-col items-center gap-2">
              <div className="h-6 w-6 animate-spin rounded-full border-2 border-current border-t-transparent" />
              <span className="text-sm">Loading data...</span>
            </div>
          </div>
        ) : (
          <VirtualTable
            onFetchData={onFetchData}
            columnConfigs={columnConfigs}
            height={260}
            onHeaderClick={onHeaderClick}
            compact
          />
        )}
      </div>
    </Surface>
  );
}
