/**
 * Pure SQL generation for Insight queries.
 *
 * This module generates standard SQL that works across databases (DuckDB, PostgreSQL, SQLite).
 * No async operations, no data fetching - just pure SQL string generation.
 *
 * ## Column Naming Convention
 *
 * All columns use UUID-based aliases for consistency:
 * - Fields: `field_<uuid>` (e.g., `field_dd05ef4b_1234_5678_abcd_ef1234567890`)
 * - Metrics: `metric_<uuid>` (e.g., `metric_cc33dd44_1234_5678_abcd_ef1234567890`)
 *
 * This ensures:
 * - No collision handling needed (UUIDs are globally unique)
 * - Encoding value = SQL column name = axis selection key (zero transformation)
 * - Display names looked up from field/metric definitions when rendering UI
 */

import type {
  DataTable,
  Field,
  Insight,
  InsightMetric,
  UUID,
} from "@dashframe/types";

// ============================================================================
// UUID Column Naming Utilities
// ============================================================================

/**
 * Convert a field ID to a SQL-safe column alias.
 * Format: field_<uuid_with_underscores>
 *
 * @example
 * fieldIdToColumnAlias("dd05ef4b-1234-5678-abcd-ef1234567890")
 * // Returns: "field_dd05ef4b_1234_5678_abcd_ef1234567890"
 */
export function fieldIdToColumnAlias(fieldId: string): string {
  return `field_${fieldId.replace(/-/g, "_")}`;
}

/**
 * Convert a metric ID to a SQL-safe column alias.
 * Format: metric_<uuid_with_underscores>
 *
 * @example
 * metricIdToColumnAlias("cc33dd44-1234-5678-abcd-ef1234567890")
 * // Returns: "metric_cc33dd44_1234_5678_abcd_ef1234567890"
 */
export function metricIdToColumnAlias(metricId: string): string {
  return `metric_${metricId.replace(/-/g, "_")}`;
}

/**
 * Extract the original UUID from a column alias.
 * Handles both field_* and metric_* formats.
 *
 * @example
 * extractUUIDFromColumnAlias("field_dd05ef4b_1234_5678_abcd_ef1234567890")
 * // Returns: "dd05ef4b-1234-5678-abcd-ef1234567890"
 */
export function extractUUIDFromColumnAlias(columnAlias: string): string | null {
  const match = columnAlias.match(/^(?:field|metric)_(.+)$/);
  if (!match) return null;

  // Convert underscores back to hyphens in UUID format
  const uuidPart = match[1];
  // UUID format: 8-4-4-4-12 characters
  // With underscores: 8_4_4_4_12
  const parts = uuidPart.split("_");
  if (parts.length === 5) {
    return parts.join("-");
  }
  // Fallback: just replace all underscores (may not be exact UUID format)
  return uuidPart.replace(/_/g, "-");
}

// ============================================================================
// Metric SQL Expression
// ============================================================================

/**
 * Convert an InsightMetric to its SQL aggregation expression.
 *
 * This is the canonical format expected by vgplot/Mosaic for encoding values.
 * The expression matches the SQL aggregation syntax used in GROUP BY queries.
 *
 * @example
 * ```typescript
 * // Count all rows
 * metricToSqlExpression({ name: "Count", aggregation: "count" })
 * // Returns: "count(*)"
 *
 * // Count distinct values
 * metricToSqlExpression({ name: "Unique Users", aggregation: "count_distinct", columnName: "user_id" })
 * // Returns: "count_distinct(user_id)"
 *
 * // Standard aggregation
 * metricToSqlExpression({ name: "Total Sales", aggregation: "sum", columnName: "amount" })
 * // Returns: "sum(amount)"
 * ```
 */
export function metricToSqlExpression(metric: InsightMetric): string {
  const agg = metric.aggregation;

  // COUNT(*) - no column needed
  if (agg === "count" && !metric.columnName) {
    return "count(*)";
  }

  // COUNT(DISTINCT column)
  if (agg === "count_distinct" && metric.columnName) {
    return `count_distinct(${metric.columnName})`;
  }

  // Standard aggregation: SUM, AVG, MIN, MAX, COUNT
  return `${agg}(${metric.columnName ?? "*"})`;
}

/**
 * Options for building insight SQL.
 */
export interface BuildInsightSQLOptions {
  /**
   * Query mode:
   * - "model": Raw joined data without aggregations (for data preview)
   * - "query": Aggregated data with GROUP BY and metrics (for insight results)
   */
  mode: "model" | "query";
  /** Maximum number of rows to return */
  limit?: number;
  /** Number of rows to skip */
  offset?: number;
  /** Column to sort by */
  sortColumn?: string;
  /** Sort direction */
  sortDirection?: "asc" | "desc";
}

/**
 * Shortens auto-generated table names by removing UUIDs and file extensions.
 *
 * Examples:
 * - "sales_data_a1b2c3d4-e5f6-7890-abcd-ef1234567890.csv" -> "sales_data"
 * - "customers_12345678-1234-1234-1234-123456789012_v2" -> "customers_v2"
 */
export function shortenAutoGeneratedName(name: string): string {
  let cleaned = name.replace(/\.(csv|xlsx|json)$/i, "");
  cleaned = cleaned.replace(
    /[_-]?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}[_-]?/gi,
    "",
  );
  cleaned = cleaned.replace(/[_-]\d+$/, "");
  // eslint-disable-next-line sonarjs/slow-regex
  cleaned = cleaned.replace(/(^_+)|(_+$)/g, "");
  return cleaned || name;
}

/**
 * Generates the DuckDB table name from a dataFrameId.
 * Format: df_<uuid_with_underscores>
 */
export function getTableName(dataFrameId: string): string {
  return `df_${dataFrameId.replace(/-/g, "_")}`;
}

/**
 * Builds SQL for an insight query.
 *
 * Two modes:
 * 1. Model mode: Shows raw joined data without aggregations
 * 2. Query mode: Applies GROUP BY, aggregations, and metrics
 *
 * @param baseTable - The base table for the query
 * @param joinedTables - Map of rightTableId -> DataTable for joined tables
 * @param insight - The insight configuration (selectedFields, metrics, joins)
 * @param options - Query options (mode, limit, offset, sort)
 * @returns SQL string or null if baseTable has no dataFrameId
 *
 * @example
 * ```typescript
 * const sql = buildInsightSQL(
 *   baseTable,
 *   new Map([[joinTableId, joinTable]]),
 *   insight,
 *   { mode: "query", limit: 100 }
 * );
 * ```
 */
export function buildInsightSQL(
  baseTable: DataTable,
  joinedTables: Map<UUID, DataTable>,
  insight: Insight,
  options: BuildInsightSQLOptions,
): string | null {
  const { mode } = options;

  if (!baseTable.dataFrameId) return null;

  const baseDFTable = getTableName(baseTable.dataFrameId);
  const baseDisplayName = shortenAutoGeneratedName(baseTable.name);
  const baseFields = (baseTable.fields ?? []).filter(
    (f) => !f.name.startsWith("_"),
  );

  // No joins: simple query on base table with alias
  if (!insight.joins?.length) {
    return buildSimpleSQL(
      baseDFTable,
      baseDisplayName,
      baseFields,
      insight,
      options,
    );
  }

  // Build joined SQL
  const joinedSQL = buildJoinedSQL(
    baseDFTable,
    baseDisplayName,
    baseFields,
    insight,
    joinedTables,
  );

  if (!joinedSQL) return null;

  // Query mode: collect all fields from base + joined tables for field ID resolution
  const allFields = [...baseFields];
  for (const [, joinTable] of joinedTables) {
    const joinFields = (joinTable.fields ?? []).filter(
      (f) => !f.name.startsWith("_"),
    );
    allFields.push(...joinFields);
  }

  // Model mode: raw data without transformations
  if (mode === "model") {
    // Build set of valid column names from all fields (no metrics in model mode)
    const validColumns = new Set(allFields.map((f) => f.columnName ?? f.name));
    return appendPagination(
      `SELECT * FROM ${joinedSQL}`,
      options,
      validColumns,
    );
  }

  // Apply aggregations with all available fields
  return buildAggregatedSQL(joinedSQL, allFields, insight, options);
}

/**
 * Builds SQL for a simple query without joins.
 *
 * In model mode, wraps the table with UUID-aliased columns for consistency
 * with joined queries. This ensures Chart components always receive the same
 * column format regardless of whether joins exist.
 */
function buildSimpleSQL(
  tableName: string,
  displayName: string,
  baseFields: Field[],
  insight: Insight,
  options: BuildInsightSQLOptions,
): string {
  const { mode } = options;

  // Model mode or no configuration: return all rows with UUID aliases
  if (
    mode === "model" ||
    (!insight.selectedFields?.length && !insight.metrics?.length)
  ) {
    // Build SELECT with UUID aliases for consistency
    const selectParts = buildFieldSelects(displayName, baseFields);
    const validColumns = new Set(
      baseFields.map((f) => fieldIdToColumnAlias(f.id)),
    );
    return appendPagination(
      `SELECT ${selectParts.join(", ")} FROM ${tableName} AS "${displayName}"`,
      options,
      validColumns,
    );
  }

  // Query mode with configuration: wrap table with UUID aliases, then apply aggregations
  // This ensures the FROM clause for aggregation has UUID-aliased columns
  const selectParts = buildFieldSelects(displayName, baseFields);
  const wrappedFromClause = `(SELECT ${selectParts.join(", ")} FROM ${tableName} AS "${displayName}")`;

  return buildAggregatedSQL(wrappedFromClause, baseFields, insight, options);
}

// ============================================================================
// Join SQL Helpers
// ============================================================================

/** Find a field by its column name (or name fallback) */
function findFieldByColumnName(
  fields: Field[],
  columnName: string,
): Field | undefined {
  return fields.find((f) => (f.columnName ?? f.name) === columnName);
}

/**
 * Build SELECT part for a column using UUID-based alias.
 * Format: "tableName"."columnName" AS "field_<uuid>"
 *
 * No collision handling needed - UUIDs are globally unique.
 */
function buildColumnSelectWithFieldId(
  tableName: string,
  columnName: string,
  fieldId: string,
): string {
  const alias = fieldIdToColumnAlias(fieldId);
  return `"${tableName}"."${columnName}" AS "${alias}"`;
}

/** Build SELECT parts for all fields from a table using UUID aliases */
function buildFieldSelects(tableName: string, fields: Field[]): string[] {
  return fields.map((field) => {
    const columnName = field.columnName ?? field.name;
    return buildColumnSelectWithFieldId(tableName, columnName, field.id);
  });
}

/**
 * Builds the JOIN SQL using UUID-based column aliases.
 * No collision handling needed - UUIDs are globally unique.
 *
 * The first step wraps the base table with UUID aliases, then subsequent joins
 * can reference columns by their UUID alias names.
 */
function buildJoinedSQL(
  baseDFTable: string,
  baseDisplayName: string,
  baseFields: Field[],
  insight: Insight,
  joinedTables: Map<UUID, DataTable>,
): string | null {
  // First, wrap base table with UUID-aliased columns
  const baseSelects = buildFieldSelects(baseDisplayName, baseFields);
  let currentSQL = `(SELECT ${baseSelects.join(", ")} FROM ${baseDFTable} AS "${baseDisplayName}")`;
  let currentFields = baseFields;

  for (const join of insight.joins ?? []) {
    const joinResult = processSingleJoin(
      join,
      joinedTables,
      currentSQL,
      baseDisplayName,
      currentFields,
    );

    if (joinResult) {
      currentSQL = joinResult.sql;
      // Accumulate fields from all joined tables for subsequent joins
      currentFields = joinResult.allFields;
    }
  }

  return currentSQL;
}

/** Result from processing a single join */
interface JoinResult {
  sql: string;
  allFields: Field[];
  displayName: string;
}

/**
 * Process a single join and return the updated SQL with UUID-based column aliases.
 * Returns null if join is invalid.
 */
function processSingleJoin(
  join: NonNullable<Insight["joins"]>[number],
  joinedTables: Map<UUID, DataTable>,
  currentSQL: string,
  currentDisplayName: string,
  currentFields: Field[],
): JoinResult | null {
  // Validate join table
  const joinTable = joinedTables.get(join.rightTableId);
  if (!joinTable) {
    console.warn(`Join table ${join.rightTableId} not found in joinedTables`);
    return null;
  }
  if (!joinTable.dataFrameId) {
    console.warn(`Join table ${joinTable.name} has no dataFrameId`);
    return null;
  }

  // Get join table metadata
  const joinDFTable = getTableName(joinTable.dataFrameId);
  const joinDisplayName = shortenAutoGeneratedName(joinTable.name);
  const joinFields = (joinTable.fields ?? []).filter(
    (f) => !f.name.startsWith("_"),
  );

  // Find and validate join keys
  const currentKeyField = findFieldByColumnName(currentFields, join.leftKey);
  const joinKeyField = findFieldByColumnName(joinFields, join.rightKey);
  if (!currentKeyField || !joinKeyField) {
    console.warn(
      `Join key fields not found: ${join.leftKey}, ${join.rightKey}`,
    );
    return null;
  }

  const rightColName = joinKeyField.columnName ?? joinKeyField.name;

  // Build SELECT parts using UUID-based aliases
  // For the left side, use the field alias (field_<uuid>) since it's already aliased
  const leftKeyAlias = fieldIdToColumnAlias(currentKeyField.id);
  const baseSelects = currentFields.map((field) => {
    const alias = fieldIdToColumnAlias(field.id);
    return `"${alias}"`;
  });

  // For the right side, select with UUID aliases (excluding join key to avoid duplication)
  const joinSelects = joinFields
    .filter((f) => {
      const colName = f.columnName ?? f.name;
      return colName !== rightColName;
    })
    .map((field) => {
      const columnName = field.columnName ?? field.name;
      return buildColumnSelectWithFieldId(
        joinDisplayName,
        columnName,
        field.id,
      );
    });

  const selectParts = [...baseSelects, ...joinSelects];

  // Build JOIN SQL using the UUID alias for the join condition
  const joinTypeSQL = (join.type ?? "inner").toUpperCase();
  const sql = `(
    SELECT ${selectParts.join(", ")}
    FROM ${currentSQL}
    ${joinTypeSQL} JOIN ${joinDFTable} AS "${joinDisplayName}"
    ON "${leftKeyAlias}" = "${joinDisplayName}"."${rightColName}"
  )`;

  // Combine all fields for subsequent joins (excluding duplicate join key)
  const allFields = [
    ...currentFields,
    ...joinFields.filter((f) => {
      const colName = f.columnName ?? f.name;
      return colName !== rightColName;
    }),
  ];

  return { sql, allFields, displayName: joinDisplayName };
}

// ============================================================================
// Aggregation SQL Helpers
// ============================================================================

/** Build a map from field ID to Field */
function buildFieldIdMap(fields: Field[]): Map<string, Field> {
  const map = new Map<string, Field>();
  for (const field of fields) {
    map.set(field.id, field);
  }
  return map;
}

/**
 * Build dimension column parts (SELECT and GROUP BY) from selected field IDs.
 *
 * Output uses UUID-based aliases:
 * - SELECT: `"field_<uuid>"` (passthrough since source already has this alias)
 * - GROUP BY: `"field_<uuid>"`
 * - Valid columns: `field_<uuid>` (for pagination sorting)
 */
function buildDimensionColumns(
  selectedFieldIds: string[],
  fieldIdMap: Map<string, Field>,
): { selectParts: string[]; groupByParts: string[]; columnAliases: string[] } {
  const selectParts: string[] = [];
  const groupByParts: string[] = [];
  const columnAliases: string[] = [];

  for (const fieldId of selectedFieldIds) {
    const field = fieldIdMap.get(fieldId);
    if (field) {
      const alias = fieldIdToColumnAlias(fieldId);
      // Source column already has UUID alias, just reference it
      selectParts.push(`"${alias}"`);
      groupByParts.push(`"${alias}"`);
      columnAliases.push(alias);
    }
  }

  return { selectParts, groupByParts, columnAliases };
}

/**
 * Build SQL expression for a single metric aggregation with UUID alias.
 *
 * @param metric - The metric configuration
 * @param fieldIdMap - Map of field ID to Field for resolving source column
 *
 * Output format: `AGG("source_column") AS "metric_<uuid>"`
 *
 * Note: When aggregating from a joined view, the source column is already aliased
 * as `field_<uuid>`. We need to look up the field by columnName to get its UUID.
 */
function buildMetricExpressionWithUUID(
  metric: NonNullable<Insight["metrics"]>[number],
  fieldIdMap: Map<string, Field>,
): string | null {
  const aggFn = metric.aggregation.toUpperCase();
  const outputAlias = metricIdToColumnAlias(metric.id);

  // COUNT(*) - no column needed
  if (metric.aggregation === "count" && !metric.columnName) {
    return `COUNT(*) AS "${outputAlias}"`;
  }

  if (!metric.columnName) return null;

  // Find the source field by columnName to get its UUID alias
  let sourceColumnRef: string;
  const sourceField = Array.from(fieldIdMap.values()).find(
    (f) => (f.columnName ?? f.name) === metric.columnName,
  );

  if (sourceField) {
    // Source is a field with UUID alias
    sourceColumnRef = fieldIdToColumnAlias(sourceField.id);
  } else {
    // Fallback: use raw column name (shouldn't happen with proper config)
    sourceColumnRef = metric.columnName;
  }

  // COUNT(DISTINCT column)
  if (metric.aggregation === "count_distinct") {
    return `COUNT(DISTINCT "${sourceColumnRef}") AS "${outputAlias}"`;
  }

  // Standard aggregation: SUM, AVG, MIN, MAX, COUNT
  return `${aggFn}("${sourceColumnRef}") AS "${outputAlias}"`;
}

/** Build SELECT parts for all metrics with UUID aliases */
function buildMetricColumnsWithUUID(
  metrics: NonNullable<Insight["metrics"]>,
  fieldIdMap: Map<string, Field>,
): { selectParts: string[]; columnAliases: string[] } {
  const selectParts: string[] = [];
  const columnAliases: string[] = [];

  for (const metric of metrics) {
    const expr = buildMetricExpressionWithUUID(metric, fieldIdMap);
    if (expr) {
      selectParts.push(expr);
      columnAliases.push(metricIdToColumnAlias(metric.id));
    }
  }

  return { selectParts, columnAliases };
}

/**
 * Builds aggregated SQL with GROUP BY and metrics using UUID column aliases.
 *
 * All output columns use UUID-based naming:
 * - Dimensions: `field_<uuid>`
 * - Metrics: `metric_<uuid>`
 *
 * The source FROM clause already has UUID-aliased columns from model SQL.
 */
function buildAggregatedSQL(
  fromClause: string,
  allFields: Field[],
  insight: Insight,
  options: BuildInsightSQLOptions,
): string {
  const hasSelectedFields = (insight.selectedFields?.length ?? 0) > 0;
  const hasMetrics = (insight.metrics?.length ?? 0) > 0;

  // Build field map for lookups
  const fieldIdMap = buildFieldIdMap(allFields);

  // No configuration: fall back to raw data (all fields with UUID aliases)
  if (!hasSelectedFields && !hasMetrics) {
    // Valid columns are UUID aliases
    const validColumns = new Set(
      allFields.map((f) => fieldIdToColumnAlias(f.id)),
    );
    return appendPagination(
      `SELECT * FROM ${fromClause}`,
      options,
      validColumns,
    );
  }

  // Build dimension columns with UUID aliases
  const {
    selectParts: dimensionSelects,
    groupByParts,
    columnAliases: dimensionAliases,
  } = hasSelectedFields
    ? buildDimensionColumns(insight.selectedFields!, fieldIdMap)
    : { selectParts: [], groupByParts: [], columnAliases: [] };

  // Build metric columns with UUID aliases
  const { selectParts: metricSelects, columnAliases: metricAliases } =
    hasMetrics
      ? buildMetricColumnsWithUUID(insight.metrics!, fieldIdMap)
      : { selectParts: [], columnAliases: [] };

  // Combine SELECT parts
  const selectParts = [...dimensionSelects, ...metricSelects];

  // Build set of valid columns for sorting (all use UUID aliases now)
  const validColumns = new Set<string>([...dimensionAliases, ...metricAliases]);

  // Build final SQL
  let sql = `SELECT ${selectParts.join(", ")} FROM ${fromClause}`;

  if (groupByParts.length > 0) {
    sql += ` GROUP BY ${groupByParts.join(", ")}`;
  }

  return appendPagination(sql, options, validColumns);
}

/**
 * Appends ORDER BY, LIMIT, and OFFSET clauses to SQL.
 *
 * @param sql - The base SQL query
 * @param options - Query options including sort, limit, offset
 * @param validColumns - Optional set of column names that exist in the query result.
 *                       If provided, sortColumn must be in this set to be applied.
 *                       This prevents sorting by metric columns that don't exist in model mode.
 */
function appendPagination(
  sql: string,
  options: BuildInsightSQLOptions,
  validColumns?: Set<string>,
): string {
  const { sortColumn, sortDirection, limit, offset } = options;

  // Only apply ORDER BY if sortColumn exists in valid columns (if specified)
  // This prevents errors when sorting by metric columns in model mode
  if (sortColumn && sortDirection) {
    const isValidColumn = !validColumns || validColumns.has(sortColumn);
    if (isValidColumn) {
      sql += ` ORDER BY "${sortColumn}" ${sortDirection.toUpperCase()}`;
    }
  }
  if (limit !== undefined) {
    sql += ` LIMIT ${limit}`;
  }
  if (offset !== undefined) {
    sql += ` OFFSET ${offset}`;
  }

  return sql;
}
