/**
 * Pure SQL generation for Insight queries.
 *
 * This module generates standard SQL that works across databases (DuckDB, PostgreSQL, SQLite).
 * No async operations, no data fetching - just pure SQL string generation.
 */

import type { UUID, DataTable, Insight, Field } from "@dashframe/types";

/**
 * Options for building insight SQL.
 */
export interface BuildInsightSQLOptions {
  /**
   * Query mode:
   * - "model": Raw joined data without aggregations (for data preview)
   * - "query": Aggregated data with GROUP BY and metrics (for insight results)
   */
  mode: "model" | "query";
  /** Maximum number of rows to return */
  limit?: number;
  /** Number of rows to skip */
  offset?: number;
  /** Column to sort by */
  sortColumn?: string;
  /** Sort direction */
  sortDirection?: "asc" | "desc";
}

/**
 * Shortens auto-generated table names by removing UUIDs and file extensions.
 *
 * Examples:
 * - "sales_data_a1b2c3d4-e5f6-7890-abcd-ef1234567890.csv" -> "sales_data"
 * - "customers_12345678-1234-1234-1234-123456789012_v2" -> "customers_v2"
 */
export function shortenAutoGeneratedName(name: string): string {
  let cleaned = name.replace(/\.(csv|xlsx|json)$/i, "");
  cleaned = cleaned.replace(
    /[_-]?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}[_-]?/gi,
    "",
  );
  cleaned = cleaned.replace(/[_-]\d+$/, "");
  // eslint-disable-next-line sonarjs/slow-regex
  cleaned = cleaned.replace(/(^_+)|(_+$)/g, "");
  return cleaned || name;
}

/**
 * Generates the DuckDB table name from a dataFrameId.
 * Format: df_<uuid_with_underscores>
 */
export function getTableName(dataFrameId: string): string {
  return `df_${dataFrameId.replace(/-/g, "_")}`;
}

/**
 * Builds SQL for an insight query.
 *
 * Two modes:
 * 1. Model mode: Shows raw joined data without aggregations
 * 2. Query mode: Applies GROUP BY, aggregations, and metrics
 *
 * @param baseTable - The base table for the query
 * @param joinedTables - Map of rightTableId -> DataTable for joined tables
 * @param insight - The insight configuration (selectedFields, metrics, joins)
 * @param options - Query options (mode, limit, offset, sort)
 * @returns SQL string or null if baseTable has no dataFrameId
 *
 * @example
 * ```typescript
 * const sql = buildInsightSQL(
 *   baseTable,
 *   new Map([[joinTableId, joinTable]]),
 *   insight,
 *   { mode: "query", limit: 100 }
 * );
 * ```
 */
export function buildInsightSQL(
  baseTable: DataTable,
  joinedTables: Map<UUID, DataTable>,
  insight: Insight,
  options: BuildInsightSQLOptions,
): string | null {
  const { mode } = options;

  if (!baseTable.dataFrameId) return null;

  const baseDFTable = getTableName(baseTable.dataFrameId);
  const baseDisplayName = shortenAutoGeneratedName(baseTable.name);
  const baseFields = (baseTable.fields ?? []).filter(
    (f) => !f.name.startsWith("_"),
  );

  // No joins: simple query on base table with alias
  if (!insight.joins?.length) {
    return buildSimpleSQL(
      baseDFTable,
      baseDisplayName,
      baseFields,
      insight,
      options,
    );
  }

  // Build joined SQL
  const joinedSQL = buildJoinedSQL(
    baseDFTable,
    baseDisplayName,
    baseFields,
    insight,
    joinedTables,
  );

  if (!joinedSQL) return null;

  // Model mode: raw data without transformations
  if (mode === "model") {
    return appendPagination(`SELECT * FROM ${joinedSQL}`, options);
  }

  // Query mode: apply aggregations
  return buildAggregatedSQL(joinedSQL, baseFields, insight, options);
}

/**
 * Builds SQL for a simple query without joins.
 */
function buildSimpleSQL(
  tableName: string,
  displayName: string,
  baseFields: Field[],
  insight: Insight,
  options: BuildInsightSQLOptions,
): string {
  const { mode } = options;

  // Model mode or no configuration: return all rows
  if (
    mode === "model" ||
    (!insight.selectedFields?.length && !insight.metrics?.length)
  ) {
    return appendPagination(
      `SELECT * FROM ${tableName} AS "${displayName}"`,
      options,
    );
  }

  // Query mode with configuration: apply aggregations
  return buildAggregatedSQL(
    `${tableName} AS "${displayName}"`,
    baseFields,
    insight,
    options,
  );
}

// ============================================================================
// Join SQL Helpers
// ============================================================================

/** Extract column names from fields, using columnName or falling back to name */
function getColumnNames(fields: Field[]): string[] {
  return fields.map((f) => f.columnName ?? f.name);
}

/** Find a field by its column name (or name fallback) */
function findFieldByColumnName(
  fields: Field[],
  columnName: string,
): Field | undefined {
  return fields.find((f) => (f.columnName ?? f.name) === columnName);
}

/** Build SELECT part for a column, with optional alias for collision handling */
function buildColumnSelect(
  tableName: string,
  columnName: string,
  needsAlias: boolean,
): string {
  if (needsAlias) {
    const alias = `${tableName}.${columnName}`;
    return `"${tableName}"."${columnName}" AS "${alias}"`;
  }
  return `"${tableName}"."${columnName}"`;
}

/** Check if a column name exists in another table (case-insensitive) */
function columnExistsIn(columnName: string, otherColumns: string[]): boolean {
  const lowerName = columnName.toLowerCase();
  return otherColumns.some((c) => c.toLowerCase() === lowerName);
}

/** Build SELECT parts for base table columns with collision handling */
function buildBaseColumnSelects(
  baseDisplayName: string,
  baseColNames: string[],
  joinColNames: string[],
  leftKeyColName: string,
): string[] {
  return baseColNames.map((col) => {
    const isDuplicate =
      columnExistsIn(col, joinColNames) &&
      col.toLowerCase() !== leftKeyColName.toLowerCase();
    return buildColumnSelect(baseDisplayName, col, isDuplicate);
  });
}

/** Build SELECT parts for joined table columns with collision handling */
function buildJoinColumnSelects(
  joinDisplayName: string,
  joinColNames: string[],
  baseColNamesLower: Set<string>,
): string[] {
  return joinColNames.map((col) => {
    const isDuplicate = baseColNamesLower.has(col.toLowerCase());
    return buildColumnSelect(joinDisplayName, col, isDuplicate);
  });
}

/**
 * Builds the JOIN SQL, handling column name collisions.
 */
function buildJoinedSQL(
  baseDFTable: string,
  baseDisplayName: string,
  baseFields: Field[],
  insight: Insight,
  joinedTables: Map<UUID, DataTable>,
): string | null {
  const baseColNames = getColumnNames(baseFields);
  const baseColNamesLower = new Set(baseColNames.map((c) => c.toLowerCase()));

  let currentSQL = `${baseDFTable} AS "${baseDisplayName}"`;

  for (const join of insight.joins ?? []) {
    const joinResult = processSingleJoin(
      join,
      joinedTables,
      currentSQL,
      baseDisplayName,
      baseFields,
      baseColNames,
      baseColNamesLower,
    );

    if (joinResult) {
      currentSQL = joinResult;
    }
  }

  return currentSQL;
}

/** Process a single join and return the updated SQL, or null if join is invalid */
function processSingleJoin(
  join: NonNullable<Insight["joins"]>[number],
  joinedTables: Map<UUID, DataTable>,
  currentSQL: string,
  baseDisplayName: string,
  baseFields: Field[],
  baseColNames: string[],
  baseColNamesLower: Set<string>,
): string | null {
  // Validate join table
  const joinTable = joinedTables.get(join.rightTableId);
  if (!joinTable) {
    console.warn(`Join table ${join.rightTableId} not found in joinedTables`);
    return null;
  }
  if (!joinTable.dataFrameId) {
    console.warn(`Join table ${joinTable.name} has no dataFrameId`);
    return null;
  }

  // Get join table metadata
  const joinDFTable = getTableName(joinTable.dataFrameId);
  const joinDisplayName = shortenAutoGeneratedName(joinTable.name);
  const joinFields = (joinTable.fields ?? []).filter(
    (f) => !f.name.startsWith("_"),
  );
  const joinColNames = getColumnNames(joinFields);

  // Find and validate join keys
  const baseKeyField = findFieldByColumnName(baseFields, join.leftKey);
  const joinKeyField = findFieldByColumnName(joinFields, join.rightKey);
  if (!baseKeyField || !joinKeyField) {
    console.warn(
      `Join key fields not found: ${join.leftKey}, ${join.rightKey}`,
    );
    return null;
  }

  const leftColName = baseKeyField.columnName ?? baseKeyField.name;
  const rightColName = joinKeyField.columnName ?? joinKeyField.name;

  // Build SELECT parts
  const baseSelects = buildBaseColumnSelects(
    baseDisplayName,
    baseColNames,
    joinColNames,
    leftColName,
  );
  const joinSelects = buildJoinColumnSelects(
    joinDisplayName,
    joinColNames,
    baseColNamesLower,
  );
  const selectParts = [...baseSelects, ...joinSelects];

  // Build JOIN SQL
  const joinTypeSQL = (join.type ?? "inner").toUpperCase();
  return `(
    SELECT ${selectParts.join(", ")}
    FROM ${currentSQL}
    ${joinTypeSQL} JOIN ${joinDFTable} AS "${joinDisplayName}"
    ON "${baseDisplayName}"."${leftColName}" = "${joinDisplayName}"."${rightColName}"
  )`;
}

// ============================================================================
// Aggregation SQL Helpers
// ============================================================================

/** Build a map from field ID to column name */
function buildFieldIdToColumnMap(fields: Field[]): Map<string, string> {
  const map = new Map<string, string>();
  for (const field of fields) {
    map.set(field.id, field.columnName ?? field.name);
  }
  return map;
}

/** Build dimension column parts (SELECT and GROUP BY) from selected field IDs */
function buildDimensionColumns(
  selectedFieldIds: string[],
  fieldIdToColumn: Map<string, string>,
): { selectParts: string[]; groupByParts: string[] } {
  const selectParts: string[] = [];
  const groupByParts: string[] = [];

  for (const fieldId of selectedFieldIds) {
    const columnName = fieldIdToColumn.get(fieldId);
    if (columnName) {
      selectParts.push(`"${columnName}"`);
      groupByParts.push(`"${columnName}"`);
    }
  }

  return { selectParts, groupByParts };
}

/** Build SQL expression for a single metric aggregation */
function buildMetricExpression(
  metric: NonNullable<Insight["metrics"]>[number],
): string | null {
  const aggFn = metric.aggregation.toUpperCase();

  // COUNT(*) - no column needed
  if (metric.aggregation === "count" && !metric.columnName) {
    return `COUNT(*) AS "${metric.name}"`;
  }

  // COUNT(DISTINCT column)
  if (metric.aggregation === "count_distinct" && metric.columnName) {
    return `COUNT(DISTINCT "${metric.columnName}") AS "${metric.name}"`;
  }

  // Standard aggregation: SUM, AVG, MIN, MAX, COUNT
  if (metric.columnName) {
    return `${aggFn}("${metric.columnName}") AS "${metric.name}"`;
  }

  return null;
}

/** Build SELECT parts for all metrics */
function buildMetricColumns(
  metrics: NonNullable<Insight["metrics"]>,
): string[] {
  return metrics
    .map(buildMetricExpression)
    .filter((expr): expr is string => expr !== null);
}

/**
 * Builds aggregated SQL with GROUP BY and metrics.
 */
function buildAggregatedSQL(
  fromClause: string,
  baseFields: Field[],
  insight: Insight,
  options: BuildInsightSQLOptions,
): string {
  const hasSelectedFields = (insight.selectedFields?.length ?? 0) > 0;
  const hasMetrics = (insight.metrics?.length ?? 0) > 0;

  // No configuration: fall back to raw data
  if (!hasSelectedFields && !hasMetrics) {
    return appendPagination(`SELECT * FROM ${fromClause}`, options);
  }

  // Build dimension columns (SELECT + GROUP BY)
  const fieldIdToColumn = buildFieldIdToColumnMap(baseFields);
  const { selectParts: dimensionSelects, groupByParts } = hasSelectedFields
    ? buildDimensionColumns(insight.selectedFields!, fieldIdToColumn)
    : { selectParts: [], groupByParts: [] };

  // Build metric columns
  const metricSelects = hasMetrics ? buildMetricColumns(insight.metrics!) : [];

  // Combine SELECT parts
  const selectParts = [...dimensionSelects, ...metricSelects];

  // Build final SQL
  let sql = `SELECT ${selectParts.join(", ")} FROM ${fromClause}`;

  if (groupByParts.length > 0) {
    sql += ` GROUP BY ${groupByParts.join(", ")}`;
  }

  return appendPagination(sql, options);
}

/**
 * Appends ORDER BY, LIMIT, and OFFSET clauses to SQL.
 */
function appendPagination(
  sql: string,
  options: BuildInsightSQLOptions,
): string {
  const { sortColumn, sortDirection, limit, offset } = options;

  if (sortColumn && sortDirection) {
    sql += ` ORDER BY "${sortColumn}" ${sortDirection.toUpperCase()}`;
  }
  if (limit !== undefined) {
    sql += ` LIMIT ${limit}`;
  }
  if (offset !== undefined) {
    sql += ` OFFSET ${offset}`;
  }

  return sql;
}
