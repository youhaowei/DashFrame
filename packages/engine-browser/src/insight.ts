import type {
  DataTableField,
  DataTableInfo,
  InsightMetric,
  JoinType,
  UUID,
} from "@dashframe/engine";

// Re-export from core for backwards compatibility
export type { DataTableField, DataTableInfo } from "@dashframe/engine";

// ============================================================================
// Resolved Types (for SQL Generation)
// ============================================================================

/**
 * Field with resolved column name for SQL generation.
 */
export interface InsightField {
  sourceTable: string;
  columnName: string;
  displayName: string;
}

/**
 * Metric with resolved column name for SQL generation.
 */
export interface InsightMetricResolved {
  sourceTable: string;
  columnName?: string;
  aggregation: string;
  alias: string;
  displayName: string;
}

/**
 * Join with resolved column names.
 */
export interface InsightJoin {
  tableName: string;
  displayName: string;
  columns: string[];
  joinType: JoinType;
  leftColumn: string;
  rightColumn: string;
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Shorten auto-generated table names by removing UUIDs and suffixes.
 */
export function shortenAutoGeneratedName(name: string): string {
  let cleaned = name.replace(/\.(csv|xlsx|json)$/i, "");
  cleaned = cleaned.replace(
    /[_-]?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}[_-]?/gi,
    "",
  );
  cleaned = cleaned.replace(/[_-]\d+$/, "");
  // eslint-disable-next-line sonarjs/slow-regex
  cleaned = cleaned.replace(/(^_+)|(_+$)/g, "");
  return cleaned || name;
}

// ============================================================================
// Insight Configuration Types
// ============================================================================

type FilterPredicate = {
  columnName: string;
  operator: string;
  value?: unknown;
  values?: unknown[];
};

type SortOrder = {
  columnName: string;
  direction: "asc" | "desc";
};

export type InsightConfiguration = {
  id?: UUID;
  name: string;
  baseTable: DataTableInfo;
  selectedFields?: UUID[];
  metrics?: InsightMetric[];
  joins?: Array<{
    table: DataTableInfo;
    selectedFields: UUID[];
    joinOn: { baseField: UUID; joinedField: UUID };
    joinType: "inner" | "left" | "right" | "outer";
  }>;
  filters?: FilterPredicate[];
  groupBy?: string[];
  orderBy?: SortOrder[];
  limit?: number;
};

// ============================================================================
// Insight Class
// ============================================================================

/**
 * Insight - Query configuration with embedded DataTable objects.
 */
export class Insight {
  #config: InsightConfiguration;

  constructor(config: InsightConfiguration) {
    if (!config.name) throw new Error("Insight must have a name");
    if (!config.baseTable) throw new Error("Insight must have a baseTable");

    this.#config = {
      id: config.id || crypto.randomUUID(),
      name: config.name,
      baseTable: config.baseTable,
      selectedFields: config.selectedFields || [],
      metrics: config.metrics || [],
      filters: config.filters || [],
      groupBy: config.groupBy || [],
      orderBy: config.orderBy || [],
      limit: config.limit,
      joins: config.joins || [],
    };
  }

  // Property accessors
  get id(): UUID {
    return this.#config.id!;
  }
  get name(): string {
    return this.#config.name;
  }
  get baseTable(): DataTableInfo {
    return this.#config.baseTable;
  }
  get selectedFields(): UUID[] {
    return this.#config.selectedFields || [];
  }
  get metrics(): InsightMetric[] {
    return this.#config.metrics || [];
  }
  get filters(): FilterPredicate[] {
    return this.#config.filters || [];
  }
  get groupBy(): string[] {
    return this.#config.groupBy || [];
  }
  get orderBy(): SortOrder[] {
    return this.#config.orderBy || [];
  }
  get limit(): number | undefined {
    return this.#config.limit;
  }
  get joins(): InsightConfiguration["joins"] {
    return this.#config.joins || [];
  }
  get config(): InsightConfiguration {
    return { ...this.#config };
  }

  /**
   * Generate SQL query string for this Insight.
   */
  toSQL(): string {
    const baseTable = this.baseTable;
    if (!baseTable.dataFrameId) {
      throw new Error(
        `Base DataTable ${baseTable.name} has no cached data. Load data first.`,
      );
    }

    const baseTableName = `df_${baseTable.dataFrameId.replace(/-/g, "_")}`;
    const baseFields = baseTable.fields.filter((f) => !f.name.startsWith("_"));
    const baseColNames = baseFields.map((f) => f.columnName ?? f.name);

    const fieldIdToColumn = new Map<string, string>();
    for (const field of baseFields) {
      fieldIdToColumn.set(field.id, field.columnName ?? field.name);
    }

    if (!this.joins?.length) {
      return this.generateSimpleSQL(
        baseTableName,
        baseColNames,
        baseFields,
        fieldIdToColumn,
      );
    }

    return this.generateJoinSQL(
      baseTable,
      baseTableName,
      baseFields,
      baseColNames,
      fieldIdToColumn,
    );
  }

  // eslint-disable-next-line sonarjs/cognitive-complexity
  private generateSimpleSQL(
    baseTableName: string,
    baseColNames: string[],
    baseFields: DataTableField[],
    fieldIdToColumn: Map<string, string>,
  ): string {
    const hasAggregation =
      (this.selectedFields.length > 0 || this.groupBy.length > 0) &&
      this.metrics.length > 0;

    if (!hasAggregation) {
      const selectCols = baseColNames.map((col) => `"${col}"`).join(", ");
      let sql = `SELECT ${selectCols} FROM ${baseTableName}`;
      if (this.filters.length > 0)
        sql += ` WHERE ${this.buildWhereClause(this.filters)}`;
      if (this.orderBy.length > 0)
        sql += ` ORDER BY ${this.buildOrderByClause()}`;
      if (this.limit !== undefined) sql += ` LIMIT ${this.limit}`;
      return sql;
    }

    const selectParts: string[] = [];
    const groupByParts: string[] = [];

    for (const fieldId of this.selectedFields) {
      const colName = fieldIdToColumn.get(fieldId);
      if (colName) {
        selectParts.push(`"${colName}"`);
        groupByParts.push(`"${colName}"`);
      }
    }

    for (const colName of this.groupBy) {
      if (!groupByParts.includes(`"${colName}"`)) {
        selectParts.push(`"${colName}"`);
        groupByParts.push(`"${colName}"`);
      }
    }

    for (const metric of this.metrics) {
      const aggFunc = metric.aggregation.toUpperCase();
      const colRef = metric.columnName ? `"${metric.columnName}"` : "*";
      selectParts.push(`${aggFunc}(${colRef}) AS "${metric.name}"`);
    }

    let sql = `SELECT ${selectParts.join(", ")} FROM ${baseTableName}`;
    if (this.filters.length > 0)
      sql += ` WHERE ${this.buildWhereClause(this.filters)}`;
    if (groupByParts.length > 0) sql += ` GROUP BY ${groupByParts.join(", ")}`;
    if (this.orderBy.length > 0)
      sql += ` ORDER BY ${this.buildOrderByClause()}`;
    if (this.limit !== undefined) sql += ` LIMIT ${this.limit}`;

    return sql;
  }

  // eslint-disable-next-line sonarjs/cognitive-complexity
  private generateJoinSQL(
    baseTable: DataTableInfo,
    baseTableName: string,
    baseFields: DataTableField[],
    baseColNames: string[],
    _fieldIdToColumn: Map<string, string>,
  ): string {
    const baseColNamesLower = new Set(baseColNames.map((c) => c.toLowerCase()));
    const baseDisplayName = shortenAutoGeneratedName(baseTable.name);
    const fieldIdToAlias = new Map<string, string>();
    const allColumnAliases: string[] = [];

    for (const field of baseFields) {
      fieldIdToAlias.set(field.id, field.columnName ?? field.name);
    }

    let currentSQL = baseTableName;

    for (const join of this.joins!) {
      const joinTable = join.table;
      if (!joinTable?.dataFrameId) {
        throw new Error(`Join table ${joinTable.name} has no data`);
      }

      const joinTableName = `df_${joinTable.dataFrameId.replace(/-/g, "_")}`;
      const joinDisplayName = shortenAutoGeneratedName(joinTable.name);
      const joinFields = joinTable.fields.filter(
        (f) => !f.name.startsWith("_"),
      );
      const joinColNames = joinFields.map((f) => f.columnName ?? f.name);

      const baseKeyField = baseFields.find(
        (f) => f.id === join.joinOn.baseField,
      );
      const joinKeyField = joinFields.find(
        (f) => f.id === join.joinOn.joinedField,
      );

      if (!baseKeyField || !joinKeyField) {
        throw new Error(`Join key fields not found`);
      }

      const leftColName = baseKeyField.columnName ?? baseKeyField.name;
      const rightColName = joinKeyField.columnName ?? joinKeyField.name;

      const selectParts: string[] = [];

      for (const col of baseColNames) {
        const isDuplicate =
          joinColNames.some((jc) => jc.toLowerCase() === col.toLowerCase()) &&
          col.toLowerCase() !== leftColName.toLowerCase();

        if (isDuplicate) {
          const alias = `${baseDisplayName}.${col}`;
          selectParts.push(`base."${col}" AS "${alias}"`);
          allColumnAliases.push(alias);
          const field = baseFields.find(
            (f) => (f.columnName ?? f.name) === col,
          );
          if (field) fieldIdToAlias.set(field.id, alias);
        } else {
          selectParts.push(`base."${col}"`);
          allColumnAliases.push(col);
        }
      }

      for (const col of joinColNames) {
        const isDuplicate = baseColNamesLower.has(col.toLowerCase());
        const alias = isDuplicate ? `${joinDisplayName}.${col}` : col;
        if (isDuplicate) {
          selectParts.push(`j."${col}" AS "${alias}"`);
        } else {
          selectParts.push(`j."${col}"`);
        }
        allColumnAliases.push(alias);
        const field = joinFields.find((f) => (f.columnName ?? f.name) === col);
        if (field) fieldIdToAlias.set(field.id, alias);
      }

      const joinTypeSQL = (join.joinType ?? "inner").toUpperCase();
      currentSQL = `(
        SELECT ${selectParts.join(", ")}
        FROM ${currentSQL} AS base
        ${joinTypeSQL} JOIN ${joinTableName} AS j
        ON base."${leftColName}" = j."${rightColName}"
      )`;
    }

    const hasAggregation =
      (this.selectedFields.length > 0 || this.groupBy.length > 0) &&
      this.metrics.length > 0;

    if (!hasAggregation) {
      let sql = `SELECT * FROM ${currentSQL}`;
      if (this.filters.length > 0)
        sql += ` WHERE ${this.buildWhereClause(this.filters)}`;
      if (this.orderBy.length > 0)
        sql += ` ORDER BY ${this.buildOrderByClause()}`;
      if (this.limit !== undefined) sql += ` LIMIT ${this.limit}`;
      return sql;
    }

    const selectParts: string[] = [];
    const groupByParts: string[] = [];

    for (const fieldId of this.selectedFields) {
      const colAlias = fieldIdToAlias.get(fieldId);
      if (colAlias) {
        selectParts.push(`"${colAlias}"`);
        groupByParts.push(`"${colAlias}"`);
      }
    }

    for (const colName of this.groupBy) {
      const quotedCol = `"${colName}"`;
      if (!groupByParts.includes(quotedCol)) {
        const aliasedCol = allColumnAliases.find(
          (a) => a === colName || a.endsWith(`.${colName}`),
        );
        if (aliasedCol) {
          selectParts.push(`"${aliasedCol}"`);
          groupByParts.push(`"${aliasedCol}"`);
        } else {
          selectParts.push(quotedCol);
          groupByParts.push(quotedCol);
        }
      }
    }

    for (const metric of this.metrics) {
      const aggFunc = metric.aggregation.toUpperCase();
      let colRef = metric.columnName ? `"${metric.columnName}"` : "*";
      if (metric.columnName) {
        const aliasedCol = allColumnAliases.find(
          (a) =>
            a === metric.columnName ||
            a.toLowerCase() === metric.columnName?.toLowerCase() ||
            a.endsWith(`.${metric.columnName}`),
        );
        if (aliasedCol) colRef = `"${aliasedCol}"`;
      }
      selectParts.push(`${aggFunc}(${colRef}) AS "${metric.name}"`);
    }

    let sql = `SELECT ${selectParts.join(", ")} FROM ${currentSQL}`;
    if (this.filters.length > 0)
      sql += ` WHERE ${this.buildWhereClause(this.filters)}`;
    if (groupByParts.length > 0) sql += ` GROUP BY ${groupByParts.join(", ")}`;
    if (this.orderBy.length > 0)
      sql += ` ORDER BY ${this.buildOrderByClause()}`;
    if (this.limit !== undefined) sql += ` LIMIT ${this.limit}`;

    return sql;
  }

  private buildWhereClause(filters: FilterPredicate[]): string {
    return filters
      .map((pred) => {
        const { columnName, operator, value, values } = pred;
        if (operator === "IS NULL" || operator === "IS NOT NULL") {
          return `"${columnName}" ${operator}`;
        }
        if (operator === "IN" || operator === "NOT IN") {
          const list =
            values
              ?.map((v) => (typeof v === "string" ? `'${v}'` : String(v)))
              .join(", ") || "";
          return `"${columnName}" ${operator} (${list})`;
        }
        const formattedValue =
          typeof value === "string" ? `'${value}'` : String(value ?? "NULL");
        return `"${columnName}" ${operator} ${formattedValue}`;
      })
      .join(" AND ");
  }

  private buildOrderByClause(): string {
    return this.orderBy
      .map((o) => `"${o.columnName}" ${o.direction.toUpperCase()}`)
      .join(", ");
  }

  // Immutable updates
  with(updates: Partial<InsightConfiguration>): Insight {
    return new Insight({
      ...this.config,
      ...updates,
      id: updates.id !== undefined ? updates.id : this.config.id,
    });
  }

  withSelectedFields(fieldIds: UUID[]): Insight {
    return this.with({ selectedFields: fieldIds });
  }
  withMetrics(metrics: InsightMetric[]): Insight {
    return this.with({ metrics });
  }
  withFilters(filters: FilterPredicate[]): Insight {
    return this.with({ filters });
  }
  withGroupBy(groupBy: string[]): Insight {
    return this.with({ groupBy });
  }
  withOrderBy(orderBy: SortOrder[]): Insight {
    return this.with({ orderBy });
  }
  withLimit(limit: number | undefined): Insight {
    return this.with({ limit });
  }
  withName(name: string): Insight {
    return this.with({ name });
  }

  toJSON(): InsightConfiguration {
    return { ...this.config };
  }
  static fromJSON(config: InsightConfiguration): Insight {
    return new Insight(config);
  }

  hasAnalytics(): boolean {
    return (
      this.metrics.length > 0 ||
      this.groupBy.length > 0 ||
      this.filters.length > 0
    );
  }

  isReady(): boolean {
    return this.selectedFields.length > 0 || this.hasAnalytics();
  }

  getDescription(): string {
    const parts: string[] = [];
    if (this.selectedFields.length > 0)
      parts.push(`show ${this.selectedFields.length} fields`);
    if (this.groupBy.length > 0)
      parts.push(`grouped by ${this.groupBy.join(", ")}`);
    if (this.metrics.length > 0)
      parts.push(`with metrics: ${this.metrics.map((m) => m.name).join(", ")}`);
    if (this.filters.length > 0)
      parts.push(`filtered by ${this.filters.length} conditions`);
    if (this.limit) parts.push(`limited to ${this.limit} rows`);
    return parts.length > 0 ? parts.join(", ") : "show all data";
  }
}
